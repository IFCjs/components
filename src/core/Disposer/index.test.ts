// Generated by CodiumAI

/*
Code Analysis

Main functionalities:
The Disposer class provides methods to safely remove meshes, geometries, and materials from memory to prevent memory leaks in a Three.js application. It allows for the removal of a mesh, its geometry, and its materials, as well as the recursive disposal of its children.

Methods:
- dispose(mesh: Item3D, materials = true, recursive = true): removes a mesh, its geometry, and its materials from memory. It also allows for the recursive disposal of its children.
- disposeGeometry(geometry: THREE.BufferGeometry): disposes a geometry from memory.
- disposeGeometryAndMaterials(mesh: Item3D, materials: boolean): disposes a mesh's geometry and materials from memory.
- disposeChildren(mesh: Item3D): recursively disposes a mesh's children.
- disposeMaterial(mesh: Item3D): disposes a mesh's material(s) from memory.

Fields:
- None.
*/

import { Disposer } from "./index";
import * as THREE from "three";

describe("Disposer_class", () => {
  // Tests that a mesh is successfully removed from memory with default parameters.
  it("test_removing_mesh_default_params", () => {
    const disposer = new Disposer();
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );
    disposer.dispose(mesh);
    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
    expect(mesh.children.length).toEqual(0);
  });

  // Tests that a mesh is successfully removed from memory with recursive set to false.
  it("test_removing_mesh_recursive_false", () => {
    const disposer = new Disposer();
    const parentMesh = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );
    const childMesh = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );
    parentMesh.add(childMesh);
    disposer.dispose(parentMesh, true, false);
    expect(parentMesh.parent).toBeNull();
    expect(parentMesh.material).toEqual([]);
    expect(parentMesh.children.length).toEqual(0);
    expect(childMesh.parent).toEqual(parentMesh);
    expect(childMesh.geometry).not.toBeNull();
    expect(childMesh.material).not.toEqual([]);
    expect(childMesh.children.length).toEqual(0);
  });

  // Tests that a geometry with boundsTree is successfully disposed from memory.
  it("test_disposing_geometry_with_bounds_tree", () => {
    const disposer = new Disposer();
    const geometry = new THREE.BufferGeometry();
    // @ts-ignore
    geometry.boundsTree = {};
    geometry.disposeBoundsTree = jest.fn();
    geometry.dispose = jest.fn();
    disposer.disposeGeometry(geometry);
    expect(geometry.disposeBoundsTree).toHaveBeenCalled();
    expect(geometry.dispose).toHaveBeenCalled();
  });

  // Tests that a mesh with no children is successfully removed from memory.
  it("test_removing_mesh_no_children", () => {
    const disposer = new Disposer();
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );
    mesh.children.length = 0;
    disposer.dispose(mesh);
    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
    expect(mesh.children.length).toEqual(0);
  });

  // Tests that a mesh with no materials is successfully removed from memory.
  it("test_removing_mesh_no_materials", () => {
    const disposer = new Disposer();
    const mesh = new THREE.Mesh(new THREE.BoxGeometry());
    // @ts-ignore
    mesh.material = null;
    disposer.dispose(mesh);
    expect(mesh.parent).toBeNull();
    expect(mesh.material).toEqual([]);
    expect(mesh.children.length).toEqual(0);
  });

  // Tests that a mesh is successfully removed from memory with materials set to false.
  it("test_disposing_mesh_materials_false", () => {
    const disposer = new Disposer();
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(),
      new THREE.MeshBasicMaterial()
    );
    disposer.dispose(mesh, false);
    expect(mesh.parent).toBeNull();
    expect(mesh.children.length).toEqual(0);
  });
});
