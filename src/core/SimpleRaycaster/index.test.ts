// Generated by CodiumAI

/*
Code Analysis

Main functionalities:
The SimpleRaycaster class is a component that provides a simple raycasting functionality to get items from the scene using mouse and touch events. It uses the Three.js Raycaster to throw a ray from the camera to the mouse or touch event point and returns the first item found. It also takes into account the clipping planes used by the renderer.

Methods:
- constructor(components: Components): initializes the SimpleRaycaster component with the Components instance and creates a Mouse instance to get the real position of the mouse in the Three.js canvas.
- get(): returns the Three.js Raycaster instance used by the SimpleRaycaster component.
- castRay(items?: THREE.Mesh[]): throws a ray from the camera to the mouse or touch event point and returns the first item found. It takes an optional parameter to specify the meshes to query. If not provided, it will query all the meshes stored in Components.meshes.
- filterClippingPlanes(objs: THREE.Intersection[]): filters the intersections to take into account the clipping planes used by the renderer.

Fields:
- name: a string that identifies the SimpleRaycaster component.
- enabled: a boolean that indicates whether the SimpleRaycaster component is active or not.
- _raycaster: the Three.js Raycaster instance used by the SimpleRaycaster component.
- _mouse: a Mouse instance that provides the real position of the mouse in the Three.js canvas.
- components: the Components instance used by the SimpleRaycaster component.
*/

import * as THREE from "three";
import { SimpleRaycaster } from "./index";
import { Components } from "../Components";
import { Plane } from "three";

describe("SimpleRaycaster_class", () => {
  // Tests that the castRay method correctly casts a ray and returns the first intersected object when items are provided.
  it("test_cast_ray_with_items", () => {
    const { raycaster, mesh } = mockRaycaster();
    const result = raycaster.castRay([mesh]);
    expect(result).not.toBeNull();
    expect(result?.object).toBe(mesh);
  });

  // Tests that the castRay method correctly casts a ray and returns null when no items are provided.
  it("test_cast_ray_without_items", () => {
    const { raycaster } = mockRaycaster();

    const result = raycaster.castRay();
    expect(result).toBeNull();
  });

  // Tests that the castRay method correctly casts a ray and returns null when an empty array of items is provided.
  it("test_cast_ray_with_empty_items", () => {
    const { raycaster } = mockRaycaster();
    const result = raycaster.castRay([]);
    expect(result).toBeNull();
  });

  // Tests that the castRay method correctly casts a ray and returns null when an undefined array of items is provided.
  it("test_cast_ray_with_undefined_items", () => {
    const { raycaster } = mockRaycaster();
    const result = raycaster.castRay(undefined);
    expect(result).toBeNull();
  });

  // Tests that the raycaster can be disabled and enabled again.
  it("test_disable_and_enable", () => {
    const components = new Components();
    const raycaster = new SimpleRaycaster(components);
    expect(raycaster.enabled).toBe(true);
    raycaster.enabled = false;
    expect(raycaster.enabled).toBe(false);
    raycaster.enabled = true;
    expect(raycaster.enabled).toBe(true);
  });
});

const mockRaycaster = () => {
  const components = new Components();
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera();
  const renderer = new THREE.WebGLRenderer();
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(),
    new THREE.MeshBasicMaterial()
  );

  const clippingPlanes = [];
  clippingPlanes.push(new Plane());
  clippingPlanes.push(new Plane());

  scene.add(mesh);
  components.scene = {
    name: "testScene",
    enabled: true,
    get: () => scene,
    ...mockUIProperties,
  };

  components.camera = {
    name: "testCamera",
    enabled: true,
    get: () => camera,
    ...mockUIProperties,
  };
  components.renderer = {
    name: "testRenderer",
    enabled: true,
    get: () => renderer,
    ...mockUIProperties,
    getSize: () => new THREE.Vector2(),
    resize: () => {},
    clippingPlanes,
    togglePlane: () => {},
  };
  components.meshes.push(mesh);

  return {
    mesh,
    raycaster: new SimpleRaycaster(components),
  };
};

const mockUIProperties = {
  isDisposeable: () => true,
  isResizeable: () => true,
  isUpdateable: () => true,
  isHideable: () => true,
  hasUI: () => true,
};
