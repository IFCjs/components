var xs=Object.defineProperty;var Gs=(r,n,t)=>n in r?xs(r,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[n]=t;var M=(r,n,t)=>(Gs(r,typeof n!="symbol"?n+"":n,t),t);import{d as Bt,V as g,h as ft,x as Cs,r as J,T as yt,S as bs,c as $,s as q,b9 as Vs,N as Hs,aY as _e,a as cs,aZ as vs,H as _s,e as pe,X as Ye,Y as Ts,Z as Rs,_ as ls,$ as xe,a0 as Fs,a1 as As,a2 as Ge,a3 as us,a4 as fs,a5 as Ns,a6 as Os,a7 as Ss,a8 as Ls,a9 as Ws,p as Ps,aA as ps,aB as ds,au as Ms,af as xt,i as Xs,I as de,ah as Q,b0 as zs,aC as ks,L as $s,aD as js,aE as Ks,aF as qs,aG as Qs,aH as Zs,b1 as Js,b2 as tn,b3 as en,b4 as sn,ab as We,ac as Xe,ad as nn,ae as En,ag as on,C as rn,ai as bt,aj as In}from"./web-ifc-api-CBCWqdvz.js";const Us=0,an=1,Cn=2,ze=2,Te=1.25,ke=1,te=6*4+4+4,Ce=65535,cn=Math.pow(2,-24),Re=Symbol("SKIP_GENERATION");function Tn(r){return r.index?r.index.count:r.attributes.position.count}function Nt(r){return Tn(r)/3}function Rn(r,n=ArrayBuffer){return r>65535?new Uint32Array(new n(4*r)):new Uint16Array(new n(2*r))}function ln(r,n){if(!r.index){const t=r.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Rn(t,e);r.setIndex(new Bt(s,1));for(let E=0;E<t;E++)s[E]=E}}function Ds(r){const n=Nt(r),t=r.drawRange,e=t.start/3,s=(t.start+t.count)/3,E=Math.max(0,e),i=Math.min(n,s)-E;return[{offset:Math.floor(E),count:Math.floor(i)}]}function hs(r){if(!r.groups||!r.groups.length)return Ds(r);const n=[],t=new Set,e=r.drawRange,s=e.start/3,E=(e.start+e.count)/3;for(const o of r.groups){const I=o.start/3,c=(o.start+o.count)/3;t.add(Math.max(s,I)),t.add(Math.min(E,c))}const i=Array.from(t.values()).sort((o,I)=>o-I);for(let o=0;o<i.length-1;o++){const I=i[o],c=i[o+1];n.push({offset:Math.floor(I),count:Math.floor(c-I)})}return n}function Fn(r){if(r.groups.length===0)return!1;const n=Nt(r),t=hs(r).sort((E,i)=>E.offset-i.offset),e=t[t.length-1];e.count=Math.min(n-e.offset,e.count);let s=0;return t.forEach(({count:E})=>s+=E),n!==s}function Y(r,n,t){return t.min.x=n[r],t.min.y=n[r+1],t.min.z=n[r+2],t.max.x=n[r+3],t.max.y=n[r+4],t.max.z=n[r+5],t}function An(r){r[0]=r[1]=r[2]=1/0,r[3]=r[4]=r[5]=-1/0}function $e(r){let n=-1,t=-1/0;for(let e=0;e<3;e++){const s=r[e+3]-r[e];s>t&&(t=s,n=e)}return n}function je(r,n){n.set(r)}function Ke(r,n,t){let e,s;for(let E=0;E<3;E++){const i=E+3;e=r[E],s=n[E],t[E]=e<s?e:s,e=r[i],s=n[i],t[i]=e>s?e:s}}function Vt(r,n,t){for(let e=0;e<3;e++){const s=n[r+2*e],E=n[r+2*e+1],i=s-E,o=s+E;i<t[e]&&(t[e]=i),o>t[e+3]&&(t[e+3]=o)}}function pt(r){const n=r[3]-r[0],t=r[4]-r[1],e=r[5]-r[2];return 2*(n*t+t*e+e*n)}function le(r,n,t,e,s=null){let E=1/0,i=1/0,o=1/0,I=-1/0,c=-1/0,C=-1/0,T=1/0,a=1/0,R=1/0,l=-1/0,S=-1/0,N=-1/0;const F=s!==null;for(let u=n*6,O=(n+t)*6;u<O;u+=6){const A=r[u+0],f=r[u+1],L=A-f,P=A+f;L<E&&(E=L),P>I&&(I=P),F&&A<T&&(T=A),F&&A>l&&(l=A);const p=r[u+2],U=r[u+3],D=p-U,y=p+U;D<i&&(i=D),y>c&&(c=y),F&&p<a&&(a=p),F&&p>S&&(S=p);const d=r[u+4],h=r[u+5],m=d-h,w=d+h;m<o&&(o=m),w>C&&(C=w),F&&d<R&&(R=d),F&&d>N&&(N=d)}e[0]=E,e[1]=i,e[2]=o,e[3]=I,e[4]=c,e[5]=C,F&&(s[0]=T,s[1]=a,s[2]=R,s[3]=l,s[4]=S,s[5]=N)}function un(r,n,t,e){let s=1/0,E=1/0,i=1/0,o=-1/0,I=-1/0,c=-1/0;for(let C=n*6,T=(n+t)*6;C<T;C+=6){const a=r[C+0];a<s&&(s=a),a>o&&(o=a);const R=r[C+2];R<E&&(E=R),R>I&&(I=R);const l=r[C+4];l<i&&(i=l),l>c&&(c=l)}e[0]=s,e[1]=E,e[2]=i,e[3]=o,e[4]=I,e[5]=c}function fn(r,n){An(n);const t=r.attributes.position,e=r.index?r.index.array:null,s=Nt(r),E=new Float32Array(s*6),i=t.normalized,o=t.array,I=t.offset||0;let c=3;t.isInterleavedBufferAttribute&&(c=t.data.stride);const C=["getX","getY","getZ"];for(let T=0;T<s;T++){const a=T*3,R=T*6;let l=a+0,S=a+1,N=a+2;e&&(l=e[l],S=e[S],N=e[N]),i||(l=l*c+I,S=S*c+I,N=N*c+I);for(let F=0;F<3;F++){let u,O,A;i?(u=t[C[F]](l),O=t[C[F]](S),A=t[C[F]](N)):(u=o[l+F],O=o[S+F],A=o[N+F]);let f=u;O<f&&(f=O),A<f&&(f=A);let L=u;O>L&&(L=O),A>L&&(L=A);const P=(L-f)/2,p=F*2;E[R+p+0]=f+P,E[R+p+1]=P+(Math.abs(f)+P)*cn,f<n[F]&&(n[F]=f),L>n[F+3]&&(n[F+3]=L)}}return E}const Z=32,Nn=(r,n)=>r.candidate-n.candidate,et=new Array(Z).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ht=new Float32Array(6);function On(r,n,t,e,s,E){let i=-1,o=0;if(E===Us)i=$e(n),i!==-1&&(o=(n[i]+n[i+3])/2);else if(E===an)i=$e(r),i!==-1&&(o=Sn(t,e,s,i));else if(E===Cn){const I=pt(r);let c=Te*s;const C=e*6,T=(e+s)*6;for(let a=0;a<3;a++){const R=n[a],N=(n[a+3]-R)/Z;if(s<Z/4){const F=[...et];F.length=s;let u=0;for(let A=C;A<T;A+=6,u++){const f=F[u];f.candidate=t[A+2*a],f.count=0;const{bounds:L,leftCacheBounds:P,rightCacheBounds:p}=f;for(let U=0;U<3;U++)p[U]=1/0,p[U+3]=-1/0,P[U]=1/0,P[U+3]=-1/0,L[U]=1/0,L[U+3]=-1/0;Vt(A,t,L)}F.sort(Nn);let O=s;for(let A=0;A<O;A++){const f=F[A];for(;A+1<O&&F[A+1].candidate===f.candidate;)F.splice(A+1,1),O--}for(let A=C;A<T;A+=6){const f=t[A+2*a];for(let L=0;L<O;L++){const P=F[L];f>=P.candidate?Vt(A,t,P.rightCacheBounds):(Vt(A,t,P.leftCacheBounds),P.count++)}}for(let A=0;A<O;A++){const f=F[A],L=f.count,P=s-f.count,p=f.leftCacheBounds,U=f.rightCacheBounds;let D=0;L!==0&&(D=pt(p)/I);let y=0;P!==0&&(y=pt(U)/I);const d=ke+Te*(D*L+y*P);d<c&&(i=a,c=d,o=f.candidate)}}else{for(let O=0;O<Z;O++){const A=et[O];A.count=0,A.candidate=R+N+O*N;const f=A.bounds;for(let L=0;L<3;L++)f[L]=1/0,f[L+3]=-1/0}for(let O=C;O<T;O+=6){let L=~~((t[O+2*a]-R)/N);L>=Z&&(L=Z-1);const P=et[L];P.count++,Vt(O,t,P.bounds)}const F=et[Z-1];je(F.bounds,F.rightCacheBounds);for(let O=Z-2;O>=0;O--){const A=et[O],f=et[O+1];Ke(A.bounds,f.rightCacheBounds,A.rightCacheBounds)}let u=0;for(let O=0;O<Z-1;O++){const A=et[O],f=A.count,L=A.bounds,p=et[O+1].rightCacheBounds;f!==0&&(u===0?je(L,Ht):Ke(L,Ht,Ht)),u+=f;let U=0,D=0;u!==0&&(U=pt(Ht)/I);const y=s-u;y!==0&&(D=pt(p)/I);const d=ke+Te*(U*u+D*y);d<c&&(i=a,c=d,o=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${E} used.`);return{axis:i,pos:o}}function Sn(r,n,t,e){let s=0;for(let E=n,i=n+t;E<i;E++)s+=r[E*6+e*2];return s/t}class vt{constructor(){}}function Ln(r,n,t,e,s,E){let i=e,o=e+s-1;const I=E.pos,c=E.axis*2;for(;;){for(;i<=o&&t[i*6+c]<I;)i++;for(;i<=o&&t[o*6+c]>=I;)o--;if(i<o){for(let C=0;C<3;C++){let T=n[i*3+C];n[i*3+C]=n[o*3+C],n[o*3+C]=T}for(let C=0;C<6;C++){let T=t[i*6+C];t[i*6+C]=t[o*6+C],t[o*6+C]=T}i++,o--}else return i}}function Pn(r,n,t,e,s,E){let i=e,o=e+s-1;const I=E.pos,c=E.axis*2;for(;;){for(;i<=o&&t[i*6+c]<I;)i++;for(;i<=o&&t[o*6+c]>=I;)o--;if(i<o){let C=r[i];r[i]=r[o],r[o]=C;for(let T=0;T<6;T++){let a=t[i*6+T];t[i*6+T]=t[o*6+T],t[o*6+T]=a}i++,o--}else return i}}function pn(r,n){const t=(r.index?r.index.count:r.attributes.position.count)/3,e=t>2**16,s=e?4:2,E=n?new SharedArrayBuffer(t*s):new ArrayBuffer(t*s),i=e?new Uint32Array(E):new Uint16Array(E);for(let o=0,I=i.length;o<I;o++)i[o]=o;return i}function dn(r,n){const t=r.geometry,e=t.index?t.index.array:null,s=n.maxDepth,E=n.verbose,i=n.maxLeafTris,o=n.strategy,I=n.onProgress,c=Nt(t),C=r._indirectBuffer;let T=!1;const a=new Float32Array(6),R=new Float32Array(6),l=fn(t,a),S=n.indirect?Pn:Ln,N=[],F=n.indirect?Ds(t):hs(t);if(F.length===1){const A=F[0],f=new vt;f.boundingData=a,un(l,A.offset,A.count,R),O(f,A.offset,A.count,R),N.push(f)}else for(let A of F){const f=new vt;f.boundingData=new Float32Array(6),le(l,A.offset,A.count,f.boundingData,R),O(f,A.offset,A.count,R),N.push(f)}return N;function u(A){I&&I(A/c)}function O(A,f,L,P=null,p=0){if(!T&&p>=s&&(T=!0,E&&(console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),L<=i||p>=s)return u(f+L),A.offset=f,A.count=L,A;const U=On(A.boundingData,P,l,f,L,o);if(U.axis===-1)return u(f+L),A.offset=f,A.count=L,A;const D=S(C,e,l,f,L,U);if(D===f||D===f+L)u(f+L),A.offset=f,A.count=L;else{A.splitAxis=U.axis;const y=new vt,d=f,h=D-f;A.left=y,y.boundingData=new Float32Array(6),le(l,d,h,y.boundingData,R),O(y,d,h,R,p+1);const m=new vt,w=D,G=L-h;A.right=m,m.boundingData=new Float32Array(6),le(l,w,G,m.boundingData,R),O(m,w,G,R,p+1)}return A}}function Mn(r,n){const t=r.geometry;n.indirect&&(r._indirectBuffer=pn(t,n.useSharedArrayBuffer),Fn(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),r._indirectBuffer||ln(t,n);const e=dn(r,n);let s,E,i;const o=[],I=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let T=0;T<e.length;T++){const a=e[T];let R=c(a);const l=new I(te*R);s=new Float32Array(l),E=new Uint32Array(l),i=new Uint16Array(l),C(0,a),o.push(l)}r._roots=o;return;function c(T){return T.count?1:1+c(T.left)+c(T.right)}function C(T,a){const R=T/4,l=T/2,S=!!a.count,N=a.boundingData;for(let F=0;F<6;F++)s[R+F]=N[F];if(S){const F=a.offset,u=a.count;return E[R+6]=F,i[l+14]=u,i[l+15]=Ce,T+te}else{const F=a.left,u=a.right,O=a.splitAxis;let A;if(A=C(T+te,F),A/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return E[R+6]=A/4,A=C(A,u),E[R+7]=O,A}}}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let e=1/0,s=-1/0;for(let E=0,i=n.length;E<i;E++){const I=n[E][t];e=I<e?I:e,s=I>s?I:s}this.min=e,this.max=s}setFromPoints(n,t){let e=1/0,s=-1/0;for(let E=0,i=t.length;E<i;E++){const o=t[E],I=n.dot(o);e=I<e?I:e,s=I>s?I:s}this.min=e,this.max=s}isSeparated(n){return this.min>n.max||n.min>this.max}}tt.prototype.setFromBox=function(){const r=new g;return function(t,e){const s=e.min,E=e.max;let i=1/0,o=-1/0;for(let I=0;I<=1;I++)for(let c=0;c<=1;c++)for(let C=0;C<=1;C++){r.x=s.x*I+E.x*(1-I),r.y=s.y*c+E.y*(1-c),r.z=s.z*C+E.z*(1-C);const T=t.dot(r);i=Math.min(T,i),o=Math.max(T,o)}this.min=i,this.max=o}}();const Un=function(){const r=new g,n=new g,t=new g;return function(s,E,i){const o=s.start,I=r,c=E.start,C=n;t.subVectors(o,c),r.subVectors(s.end,s.start),n.subVectors(E.end,E.start);const T=t.dot(C),a=C.dot(I),R=C.dot(C),l=t.dot(I),N=I.dot(I)*R-a*a;let F,u;N!==0?F=(T*a-l*R)/N:F=0,u=(T+F*a)/R,i.x=F,i.y=u}}(),be=function(){const r=new ft,n=new g,t=new g;return function(s,E,i,o){Un(s,E,r);let I=r.x,c=r.y;if(I>=0&&I<=1&&c>=0&&c<=1){s.at(I,i),E.at(c,o);return}else if(I>=0&&I<=1){c<0?E.at(0,o):E.at(1,o),s.closestPointToPoint(o,!0,i);return}else if(c>=0&&c<=1){I<0?s.at(0,i):s.at(1,i),E.closestPointToPoint(i,!0,o);return}else{let C;I<0?C=s.start:C=s.end;let T;c<0?T=E.start:T=E.end;const a=n,R=t;if(s.closestPointToPoint(T,!0,n),E.closestPointToPoint(C,!0,t),a.distanceToSquared(T)<=R.distanceToSquared(C)){i.copy(a),o.copy(T);return}else{i.copy(C),o.copy(R);return}}}}(),Dn=function(){const r=new g,n=new g,t=new Cs,e=new J;return function(E,i){const{radius:o,center:I}=E,{a:c,b:C,c:T}=i;if(e.start=c,e.end=C,e.closestPointToPoint(I,!0,r).distanceTo(I)<=o||(e.start=c,e.end=T,e.closestPointToPoint(I,!0,r).distanceTo(I)<=o)||(e.start=C,e.end=T,e.closestPointToPoint(I,!0,r).distanceTo(I)<=o))return!0;const S=i.getPlane(t);if(Math.abs(S.distanceToPoint(I))<=o){const F=S.projectPoint(I,n);if(i.containsPoint(F))return!0}return!1}}(),hn=1e-15;function Fe(r){return Math.abs(r)<hn}class K extends yt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new g),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.sphere=new bs,this.plane=new Cs,this.needsUpdate=!0}intersectsSphere(n){return Dn(n,this)}update(){const n=this.a,t=this.b,e=this.c,s=this.points,E=this.satAxes,i=this.satBounds,o=E[0],I=i[0];this.getNormal(o),I.setFromPoints(o,s);const c=E[1],C=i[1];c.subVectors(n,t),C.setFromPoints(c,s);const T=E[2],a=i[2];T.subVectors(t,e),a.setFromPoints(T,s);const R=E[3],l=i[3];R.subVectors(e,n),l.setFromPoints(R,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,n),this.needsUpdate=!1}}K.prototype.closestPointToSegment=function(){const r=new g,n=new g,t=new J;return function(s,E=null,i=null){const{start:o,end:I}=s,c=this.points;let C,T=1/0;for(let a=0;a<3;a++){const R=(a+1)%3;t.start.copy(c[a]),t.end.copy(c[R]),be(t,s,r,n),C=r.distanceToSquared(n),C<T&&(T=C,E&&E.copy(r),i&&i.copy(n))}return this.closestPointToPoint(o,r),C=o.distanceToSquared(r),C<T&&(T=C,E&&E.copy(r),i&&i.copy(o)),this.closestPointToPoint(I,r),C=I.distanceToSquared(r),C<T&&(T=C,E&&E.copy(r),i&&i.copy(I)),Math.sqrt(T)}}();K.prototype.intersectsTriangle=function(){const r=new K,n=new Array(3),t=new Array(3),e=new tt,s=new tt,E=new g,i=new g,o=new g,I=new g,c=new g,C=new J,T=new J,a=new J,R=new g;function l(S,N,F){const u=S.points;let O=0,A=-1;for(let f=0;f<3;f++){const{start:L,end:P}=C;L.copy(u[f]),P.copy(u[(f+1)%3]),C.delta(i);const p=Fe(N.distanceToPoint(L));if(Fe(N.normal.dot(i))&&p){F.copy(C),O=2;break}const U=N.intersectLine(C,R);if(!U&&p&&R.copy(L),(U||p)&&!Fe(R.distanceTo(P))){if(O<=1)(O===1?F.start:F.end).copy(R),p&&(A=O);else if(O>=2){(A===1?F.start:F.end).copy(R),O=2;break}if(O++,O===2&&A===-1)break}}return O}return function(N,F=null,u=!1){this.needsUpdate&&this.update(),N.isExtendedTriangle?N.needsUpdate&&N.update():(r.copy(N),r.update(),N=r);const O=this.plane,A=N.plane;if(Math.abs(O.normal.dot(A.normal))>1-1e-10){const f=this.satBounds,L=this.satAxes;t[0]=N.a,t[1]=N.b,t[2]=N.c;for(let U=0;U<4;U++){const D=f[U],y=L[U];if(e.setFromPoints(y,t),D.isSeparated(e))return!1}const P=N.satBounds,p=N.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let U=0;U<4;U++){const D=P[U],y=p[U];if(e.setFromPoints(y,n),D.isSeparated(e))return!1}for(let U=0;U<4;U++){const D=L[U];for(let y=0;y<4;y++){const d=p[y];if(E.crossVectors(D,d),e.setFromPoints(E,n),s.setFromPoints(E,t),e.isSeparated(s))return!1}}return F&&(u||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),F.start.set(0,0,0),F.end.set(0,0,0)),!0}else{const f=l(this,A,T);if(f===1&&N.containsPoint(T.end))return F&&(F.start.copy(T.end),F.end.copy(T.end)),!0;if(f!==2)return!1;const L=l(N,O,a);if(L===1&&this.containsPoint(a.end))return F&&(F.start.copy(a.end),F.end.copy(a.end)),!0;if(L!==2)return!1;if(T.delta(o),a.delta(I),o.dot(I)<0){let h=a.start;a.start=a.end,a.end=h}const P=T.start.dot(o),p=T.end.dot(o),U=a.start.dot(o),D=a.end.dot(o),y=p<U,d=P<D;return P!==D&&U!==p&&y===d?!1:(F&&(c.subVectors(T.start,a.start),c.dot(o)>0?F.start.copy(T.start):F.start.copy(a.start),c.subVectors(T.end,a.end),c.dot(o)<0?F.end.copy(T.end):F.end.copy(a.end)),!0)}}}();K.prototype.distanceToPoint=function(){const r=new g;return function(t){return this.closestPointToPoint(t,r),t.distanceTo(r)}}();K.prototype.distanceToTriangle=function(){const r=new g,n=new g,t=["a","b","c"],e=new J,s=new J;return function(i,o=null,I=null){const c=o||I?e:null;if(this.intersectsTriangle(i,c))return(o||I)&&(o&&c.getCenter(o),I&&c.getCenter(I)),0;let C=1/0;for(let T=0;T<3;T++){let a;const R=t[T],l=i[R];this.closestPointToPoint(l,r),a=l.distanceToSquared(r),a<C&&(C=a,o&&o.copy(r),I&&I.copy(l));const S=this[R];i.closestPointToPoint(S,r),a=S.distanceToSquared(r),a<C&&(C=a,o&&o.copy(S),I&&I.copy(r))}for(let T=0;T<3;T++){const a=t[T],R=t[(T+1)%3];e.set(this[a],this[R]);for(let l=0;l<3;l++){const S=t[l],N=t[(l+1)%3];s.set(i[S],i[N]),be(e,s,r,n);const F=r.distanceToSquared(n);F<C&&(C=F,o&&o.copy(r),I&&I.copy(n))}}return Math.sqrt(C)}}();class H{constructor(n,t,e){this.isOrientedBox=!0,this.min=new g,this.max=new g,this.matrix=new $,this.invMatrix=new $,this.points=new Array(8).fill().map(()=>new g),this.satAxes=new Array(3).fill().map(()=>new g),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}H.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,s=this.points;for(let c=0;c<=1;c++)for(let C=0;C<=1;C++)for(let T=0;T<=1;T++){const a=1*c|2*C|4*T,R=s[a];R.x=c?e.x:t.x,R.y=C?e.y:t.y,R.z=T?e.z:t.z,R.applyMatrix4(n)}const E=this.satBounds,i=this.satAxes,o=s[0];for(let c=0;c<3;c++){const C=i[c],T=E[c],a=1<<c,R=s[a];C.subVectors(o,R),T.setFromPoints(C,s)}const I=this.alignedSatBounds;I[0].setFromPointsField(s,"x"),I[1].setFromPointsField(s,"y"),I[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();H.prototype.intersectsBox=function(){const r=new tt;return function(t){this.needsUpdate&&this.update();const e=t.min,s=t.max,E=this.satBounds,i=this.satAxes,o=this.alignedSatBounds;if(r.min=e.x,r.max=s.x,o[0].isSeparated(r)||(r.min=e.y,r.max=s.y,o[1].isSeparated(r))||(r.min=e.z,r.max=s.z,o[2].isSeparated(r)))return!1;for(let I=0;I<3;I++){const c=i[I],C=E[I];if(r.setFromBox(c,t),C.isSeparated(r))return!1}return!0}}();H.prototype.intersectsTriangle=function(){const r=new K,n=new Array(3),t=new tt,e=new tt,s=new g;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(r.copy(i),r.update(),i=r);const o=this.satBounds,I=this.satAxes;n[0]=i.a,n[1]=i.b,n[2]=i.c;for(let a=0;a<3;a++){const R=o[a],l=I[a];if(t.setFromPoints(l,n),R.isSeparated(t))return!1}const c=i.satBounds,C=i.satAxes,T=this.points;for(let a=0;a<3;a++){const R=c[a],l=C[a];if(t.setFromPoints(l,T),R.isSeparated(t))return!1}for(let a=0;a<3;a++){const R=I[a];for(let l=0;l<4;l++){const S=C[l];if(s.crossVectors(R,S),t.setFromPoints(s,n),e.setFromPoints(s,T),t.isSeparated(e))return!1}}return!0}}();H.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();H.prototype.distanceToPoint=function(){const r=new g;return function(t){return this.closestPointToPoint(t,r),t.distanceTo(r)}}();H.prototype.distanceToBox=function(){const r=["x","y","z"],n=new Array(12).fill().map(()=>new J),t=new Array(12).fill().map(()=>new J),e=new g,s=new g;return function(i,o=0,I=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(I||c)&&(i.getCenter(s),this.closestPointToPoint(s,e),i.closestPointToPoint(e,s),I&&I.copy(e),c&&c.copy(s)),0;const C=o*o,T=i.min,a=i.max,R=this.points;let l=1/0;for(let N=0;N<8;N++){const F=R[N];s.copy(F).clamp(T,a);const u=F.distanceToSquared(s);if(u<l&&(l=u,I&&I.copy(F),c&&c.copy(s),u<C))return Math.sqrt(u)}let S=0;for(let N=0;N<3;N++)for(let F=0;F<=1;F++)for(let u=0;u<=1;u++){const O=(N+1)%3,A=(N+2)%3,f=F<<O|u<<A,L=1<<N|F<<O|u<<A,P=R[f],p=R[L];n[S].set(P,p);const D=r[N],y=r[O],d=r[A],h=t[S],m=h.start,w=h.end;m[D]=T[D],m[y]=F?T[y]:a[y],m[d]=u?T[d]:a[y],w[D]=a[D],w[y]=F?T[y]:a[y],w[d]=u?T[d]:a[y],S++}for(let N=0;N<=1;N++)for(let F=0;F<=1;F++)for(let u=0;u<=1;u++){s.x=N?a.x:T.x,s.y=F?a.y:T.y,s.z=u?a.z:T.z,this.closestPointToPoint(s,e);const O=s.distanceToSquared(e);if(O<l&&(l=O,I&&I.copy(e),c&&c.copy(s),O<C))return Math.sqrt(O)}for(let N=0;N<12;N++){const F=n[N];for(let u=0;u<12;u++){const O=t[u];be(F,O,e,s);const A=e.distanceToSquared(s);if(A<l&&(l=A,I&&I.copy(e),c&&c.copy(s),A<C))return Math.sqrt(A)}}return Math.sqrt(l)}}();class Ve{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class yn extends Ve{constructor(){super(()=>new K)}}const W=new yn;function v(r,n){return n[r+15]===65535}function _(r,n){return n[r+6]}function X(r,n){return n[r+14]}function z(r){return r+8}function k(r,n){return n[r+6]}function ys(r,n){return n[r+7]}class gn{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const B=new gn;let it,ut;const rt=[],_t=new Ve(()=>new q);function mn(r,n,t,e,s,E){it=_t.getPrimitive(),ut=_t.getPrimitive(),rt.push(it,ut),B.setBuffer(r._roots[n]);const i=Me(0,r.geometry,t,e,s,E);B.clearBuffer(),_t.releasePrimitive(it),_t.releasePrimitive(ut),rt.pop(),rt.pop();const o=rt.length;return o>0&&(ut=rt[o-1],it=rt[o-2]),i}function Me(r,n,t,e,s=null,E=0,i=0){const{float32Array:o,uint16Array:I,uint32Array:c}=B;let C=r*2;if(v(C,I)){const a=_(r,c),R=X(C,I);return Y(r,o,it),e(a,R,!1,i,E+r,it)}else{let D=function(d){const{uint16Array:h,uint32Array:m}=B;let w=d*2;for(;!v(w,h);)d=z(d),w=d*2;return _(d,m)},y=function(d){const{uint16Array:h,uint32Array:m}=B;let w=d*2;for(;!v(w,h);)d=k(d,m),w=d*2;return _(d,m)+X(w,h)};const a=z(r),R=k(r,c);let l=a,S=R,N,F,u,O;if(s&&(u=it,O=ut,Y(l,o,u),Y(S,o,O),N=s(u),F=s(O),F<N)){l=R,S=a;const d=N;N=F,F=d,u=O}u||(u=it,Y(l,o,u));const A=v(l*2,I),f=t(u,A,N,i+1,E+l);let L;if(f===ze){const d=D(l),m=y(l)-d;L=e(d,m,!0,i+1,E+l,u)}else L=f&&Me(l,n,t,e,s,E,i+1);if(L)return!0;O=ut,Y(S,o,O);const P=v(S*2,I),p=t(O,P,F,i+1,E+S);let U;if(p===ze){const d=D(S),m=y(S)-d;U=e(d,m,!0,i+1,E+S,O)}else U=p&&Me(S,n,t,e,s,E,i+1);return!!U}}const dt=new g,Ae=new g;function wn(r,n,t={},e=0,s=1/0){const E=e*e,i=s*s;let o=1/0,I=null;if(r.shapecast({boundsTraverseOrder:C=>(dt.copy(n).clamp(C.min,C.max),dt.distanceToSquared(n)),intersectsBounds:(C,T,a)=>a<o&&a<i,intersectsTriangle:(C,T)=>{C.closestPointToPoint(n,dt);const a=n.distanceToSquared(dt);return a<o&&(Ae.copy(dt),o=a,I=T),a<E}}),o===1/0)return null;const c=Math.sqrt(o);return t.point?t.point.copy(Ae):t.point=Ae.clone(),t.distance=c,t.faceIndex=I,t}const It=new g,at=new g,Ct=new g,Wt=new ft,Xt=new ft,zt=new ft,qe=new g,Qe=new g,Ze=new g,kt=new g;function Bn(r,n,t,e,s,E){let i;return E===Vs?i=r.intersectTriangle(e,t,n,!0,s):i=r.intersectTriangle(n,t,e,E!==Hs,s),i===null?null:{distance:r.origin.distanceTo(s),point:s.clone()}}function Yn(r,n,t,e,s,E,i,o,I){It.fromBufferAttribute(n,E),at.fromBufferAttribute(n,i),Ct.fromBufferAttribute(n,o);const c=Bn(r,It,at,Ct,kt,I);if(c){e&&(Wt.fromBufferAttribute(e,E),Xt.fromBufferAttribute(e,i),zt.fromBufferAttribute(e,o),c.uv=yt.getInterpolation(kt,It,at,Ct,Wt,Xt,zt,new ft)),s&&(Wt.fromBufferAttribute(s,E),Xt.fromBufferAttribute(s,i),zt.fromBufferAttribute(s,o),c.uv1=yt.getInterpolation(kt,It,at,Ct,Wt,Xt,zt,new ft)),t&&(qe.fromBufferAttribute(t,E),Qe.fromBufferAttribute(t,i),Ze.fromBufferAttribute(t,o),c.normal=yt.getInterpolation(kt,It,at,Ct,qe,Qe,Ze,new g),c.normal.dot(r.direction)>0&&c.normal.multiplyScalar(-1));const C={a:E,b:i,c:o,normal:new g,materialIndex:0};yt.getNormal(It,at,Ct,C.normal),c.face=C,c.faceIndex=E}return c}function ce(r,n,t,e,s){const E=e*3;let i=E+0,o=E+1,I=E+2;const c=r.index;r.index&&(i=c.getX(i),o=c.getX(o),I=c.getX(I));const{position:C,normal:T,uv:a,uv1:R}=r.attributes,l=Yn(t,C,T,a,R,i,o,I,n);return l?(l.faceIndex=e,s&&s.push(l),l):null}function V(r,n,t,e){const s=r.a,E=r.b,i=r.c;let o=n,I=n+1,c=n+2;t&&(o=t.getX(o),I=t.getX(I),c=t.getX(c)),s.x=e.getX(o),s.y=e.getY(o),s.z=e.getZ(o),E.x=e.getX(I),E.y=e.getY(I),E.z=e.getZ(I),i.x=e.getX(c),i.y=e.getY(c),i.z=e.getZ(c)}function xn(r,n,t,e,s,E){const{geometry:i,_indirectBuffer:o}=r;for(let I=e,c=e+s;I<c;I++)ce(i,n,t,I,E)}function Gn(r,n,t,e,s){const{geometry:E,_indirectBuffer:i}=r;let o=1/0,I=null;for(let c=e,C=e+s;c<C;c++){let T;T=ce(E,n,t,c),T&&T.distance<o&&(I=T,o=T.distance)}return I}function bn(r,n,t,e,s,E,i){const{geometry:o}=t,{index:I}=o,c=o.attributes.position;for(let C=r,T=n+r;C<T;C++){let a;if(a=C,V(i,a*3,I,c),i.needsUpdate=!0,e(i,a,s,E))return!0}return!1}function Vn(r,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=r.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let E,i,o,I,c=0;const C=r._roots;for(let a=0,R=C.length;a<R;a++)E=C[a],i=new Uint32Array(E),o=new Uint16Array(E),I=new Float32Array(E),T(0,c),c+=E.byteLength;function T(a,R,l=!1){const S=a*2;if(o[S+15]===Ce){const F=i[a+6],u=o[S+14];let O=1/0,A=1/0,f=1/0,L=-1/0,P=-1/0,p=-1/0;for(let U=3*F,D=3*(F+u);U<D;U++){let y=e[U];const d=s.getX(y),h=s.getY(y),m=s.getZ(y);d<O&&(O=d),d>L&&(L=d),h<A&&(A=h),h>P&&(P=h),m<f&&(f=m),m>p&&(p=m)}return I[a+0]!==O||I[a+1]!==A||I[a+2]!==f||I[a+3]!==L||I[a+4]!==P||I[a+5]!==p?(I[a+0]=O,I[a+1]=A,I[a+2]=f,I[a+3]=L,I[a+4]=P,I[a+5]=p,!0):!1}else{const F=a+8,u=i[a+6],O=F+R,A=u+R;let f=l,L=!1,P=!1;n?f||(L=n.has(O),P=n.has(A),f=!L&&!P):(L=!0,P=!0);const p=f||L,U=f||P;let D=!1;p&&(D=T(F,R,f));let y=!1;U&&(y=T(u,R,f));const d=D||y;if(d)for(let h=0;h<3;h++){const m=F+h,w=u+h,G=I[m],St=I[m+3],Lt=I[w],Pt=I[w+3];I[a+h]=G<Lt?G:Lt,I[a+h+3]=St>Pt?St:Pt}return d}}}const Je=new q;function Et(r,n,t,e){return Y(r,n,Je),t.intersectBox(Je,e)}function Hn(r,n,t,e,s,E){const{geometry:i,_indirectBuffer:o}=r;for(let I=e,c=e+s;I<c;I++){let C=o?o[I]:I;ce(i,n,t,C,E)}}function vn(r,n,t,e,s){const{geometry:E,_indirectBuffer:i}=r;let o=1/0,I=null;for(let c=e,C=e+s;c<C;c++){let T;T=ce(E,n,t,i?i[c]:c),T&&T.distance<o&&(I=T,o=T.distance)}return I}function _n(r,n,t,e,s,E,i){const{geometry:o}=t,{index:I}=o,c=o.attributes.position;for(let C=r,T=n+r;C<T;C++){let a;if(a=t.resolveTriangleIndex(C),V(i,a*3,I,c),i.needsUpdate=!0,e(i,a,s,E))return!0}return!1}const ts=new g;function Wn(r,n,t,e,s){B.setBuffer(r._roots[n]),Ue(0,r,t,e,s),B.clearBuffer()}function Ue(r,n,t,e,s){const{float32Array:E,uint16Array:i,uint32Array:o}=B,I=r*2;if(v(I,i)){const C=_(r,o),T=X(I,i);xn(n,t,e,C,T,s)}else{const C=z(r);Et(C,E,e,ts)&&Ue(C,n,t,e,s);const T=k(r,o);Et(T,E,e,ts)&&Ue(T,n,t,e,s)}}const es=new g,Xn=["x","y","z"];function zn(r,n,t,e){B.setBuffer(r._roots[n]);const s=De(0,r,t,e);return B.clearBuffer(),s}function De(r,n,t,e){const{float32Array:s,uint16Array:E,uint32Array:i}=B;let o=r*2;if(v(o,E)){const c=_(r,i),C=X(o,E);return Gn(n,t,e,c,C)}else{const c=ys(r,i),C=Xn[c],a=e.direction[C]>=0;let R,l;a?(R=z(r),l=k(r,i)):(R=k(r,i),l=z(r));const N=Et(R,s,e,es)?De(R,n,t,e):null;if(N){const O=N.point[C];if(a?O<=s[l+c]:O>=s[l+c+3])return N}const u=Et(l,s,e,es)?De(l,n,t,e):null;return N&&u?N.distance<=u.distance?N:u:N||u||null}}const $t=new q,ct=new K,Tt=new K,Mt=new $,ss=new H,jt=new H;function kn(r,n,t,e){B.setBuffer(r._roots[n]);const s=he(0,r,t,e);return B.clearBuffer(),s}function he(r,n,t,e,s=null){const{float32Array:E,uint16Array:i,uint32Array:o}=B;let I=r*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),ss.set(t.boundingBox.min,t.boundingBox.max,e),s=ss),v(I,i)){const C=n.geometry,T=C.index,a=C.attributes.position,R=t.index,l=t.attributes.position,S=_(r,o),N=X(I,i);if(Mt.copy(e).invert(),t.boundsTree)return Y(r,E,jt),jt.matrix.copy(Mt),jt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:u=>jt.intersectsBox(u),intersectsTriangle:u=>{u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let O=S*3,A=(N+S)*3;O<A;O+=3)if(V(Tt,O,T,a),Tt.needsUpdate=!0,u.intersectsTriangle(Tt))return!0;return!1}});for(let F=S*3,u=(N+S)*3;F<u;F+=3){V(ct,F,T,a),ct.a.applyMatrix4(Mt),ct.b.applyMatrix4(Mt),ct.c.applyMatrix4(Mt),ct.needsUpdate=!0;for(let O=0,A=R.count;O<A;O+=3)if(V(Tt,O,R,l),Tt.needsUpdate=!0,ct.intersectsTriangle(Tt))return!0}}else{const C=r+8,T=o[r+6];return Y(C,E,$t),!!(s.intersectsBox($t)&&he(C,n,t,e,s)||(Y(T,E,$t),s.intersectsBox($t)&&he(T,n,t,e,s)))}}const Kt=new $,ue=new H,Ut=new H,$n=new g,jn=new g,Kn=new g,qn=new g;function Qn(r,n,t,e={},s={},E=0,i=1/0){n.boundingBox||n.computeBoundingBox(),ue.set(n.boundingBox.min,n.boundingBox.max,t),ue.needsUpdate=!0;const o=r.geometry,I=o.attributes.position,c=o.index,C=n.attributes.position,T=n.index,a=W.getPrimitive(),R=W.getPrimitive();let l=$n,S=jn,N=null,F=null;s&&(N=Kn,F=qn);let u=1/0,O=null,A=null;return Kt.copy(t).invert(),Ut.matrix.copy(Kt),r.shapecast({boundsTraverseOrder:f=>ue.distanceToBox(f),intersectsBounds:(f,L,P)=>P<u&&P<i?(L&&(Ut.min.copy(f.min),Ut.max.copy(f.max),Ut.needsUpdate=!0),!0):!1,intersectsRange:(f,L)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:p=>Ut.distanceToBox(p),intersectsBounds:(p,U,D)=>D<u&&D<i,intersectsRange:(p,U)=>{for(let D=p,y=p+U;D<y;D++){V(R,3*D,T,C),R.a.applyMatrix4(t),R.b.applyMatrix4(t),R.c.applyMatrix4(t),R.needsUpdate=!0;for(let d=f,h=f+L;d<h;d++){V(a,3*d,c,I),a.needsUpdate=!0;const m=a.distanceToTriangle(R,l,N);if(m<u&&(S.copy(l),F&&F.copy(N),u=m,O=d,A=D),m<E)return!0}}}});{const P=Nt(n);for(let p=0,U=P;p<U;p++){V(R,3*p,T,C),R.a.applyMatrix4(t),R.b.applyMatrix4(t),R.c.applyMatrix4(t),R.needsUpdate=!0;for(let D=f,y=f+L;D<y;D++){V(a,3*D,c,I),a.needsUpdate=!0;const d=a.distanceToTriangle(R,l,N);if(d<u&&(S.copy(l),F&&F.copy(N),u=d,O=D,A=p),d<E)return!0}}}}}),W.releasePrimitive(a),W.releasePrimitive(R),u===1/0?null:(e.point?e.point.copy(S):e.point=S.clone(),e.distance=u,e.faceIndex=O,s&&(s.point?s.point.copy(F):s.point=F.clone(),s.point.applyMatrix4(Kt),S.applyMatrix4(Kt),s.distance=S.sub(s.point).length(),s.faceIndex=A),e)}function Zn(r,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=r.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let E,i,o,I,c=0;const C=r._roots;for(let a=0,R=C.length;a<R;a++)E=C[a],i=new Uint32Array(E),o=new Uint16Array(E),I=new Float32Array(E),T(0,c),c+=E.byteLength;function T(a,R,l=!1){const S=a*2;if(o[S+15]===Ce){const F=i[a+6],u=o[S+14];let O=1/0,A=1/0,f=1/0,L=-1/0,P=-1/0,p=-1/0;for(let U=F,D=F+u;U<D;U++){const y=3*r.resolveTriangleIndex(U);for(let d=0;d<3;d++){let h=y+d;h=e?e[h]:h;const m=s.getX(h),w=s.getY(h),G=s.getZ(h);m<O&&(O=m),m>L&&(L=m),w<A&&(A=w),w>P&&(P=w),G<f&&(f=G),G>p&&(p=G)}}return I[a+0]!==O||I[a+1]!==A||I[a+2]!==f||I[a+3]!==L||I[a+4]!==P||I[a+5]!==p?(I[a+0]=O,I[a+1]=A,I[a+2]=f,I[a+3]=L,I[a+4]=P,I[a+5]=p,!0):!1}else{const F=a+8,u=i[a+6],O=F+R,A=u+R;let f=l,L=!1,P=!1;n?f||(L=n.has(O),P=n.has(A),f=!L&&!P):(L=!0,P=!0);const p=f||L,U=f||P;let D=!1;p&&(D=T(F,R,f));let y=!1;U&&(y=T(u,R,f));const d=D||y;if(d)for(let h=0;h<3;h++){const m=F+h,w=u+h,G=I[m],St=I[m+3],Lt=I[w],Pt=I[w+3];I[a+h]=G<Lt?G:Lt,I[a+h+3]=St>Pt?St:Pt}return d}}}const ns=new g;function Jn(r,n,t,e,s){B.setBuffer(r._roots[n]),ye(0,r,t,e,s),B.clearBuffer()}function ye(r,n,t,e,s){const{float32Array:E,uint16Array:i,uint32Array:o}=B,I=r*2;if(v(I,i)){const C=_(r,o),T=X(I,i);Hn(n,t,e,C,T,s)}else{const C=z(r);Et(C,E,e,ns)&&ye(C,n,t,e,s);const T=k(r,o);Et(T,E,e,ns)&&ye(T,n,t,e,s)}}const is=new g,ti=["x","y","z"];function ei(r,n,t,e){B.setBuffer(r._roots[n]);const s=ge(0,r,t,e);return B.clearBuffer(),s}function ge(r,n,t,e){const{float32Array:s,uint16Array:E,uint32Array:i}=B;let o=r*2;if(v(o,E)){const c=_(r,i),C=X(o,E);return vn(n,t,e,c,C)}else{const c=ys(r,i),C=ti[c],a=e.direction[C]>=0;let R,l;a?(R=z(r),l=k(r,i)):(R=k(r,i),l=z(r));const N=Et(R,s,e,is)?ge(R,n,t,e):null;if(N){const O=N.point[C];if(a?O<=s[l+c]:O>=s[l+c+3])return N}const u=Et(l,s,e,is)?ge(l,n,t,e):null;return N&&u?N.distance<=u.distance?N:u:N||u||null}}const qt=new q,Rt=new K,lt=new K,Dt=new $,Es=new H,Qt=new H;function si(r,n,t,e){B.setBuffer(r._roots[n]);const s=me(0,r,t,e);return B.clearBuffer(),s}function me(r,n,t,e,s=null){const{float32Array:E,uint16Array:i,uint32Array:o}=B;let I=r*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),Es.set(t.boundingBox.min,t.boundingBox.max,e),s=Es),v(I,i)){const C=n.geometry,T=C.index,a=C.attributes.position,R=t.index,l=t.attributes.position,S=_(r,o),N=X(I,i);if(Dt.copy(e).invert(),t.boundsTree)return Y(r,E,Qt),Qt.matrix.copy(Dt),Qt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:u=>Qt.intersectsBox(u),intersectsTriangle:u=>{u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let O=S,A=N+S;O<A;O++)if(V(lt,3*n.resolveTriangleIndex(O),T,a),lt.needsUpdate=!0,u.intersectsTriangle(lt))return!0;return!1}});for(let F=S,u=N+S;F<u;F++){const O=n.resolveTriangleIndex(F);V(Rt,3*O,T,a),Rt.a.applyMatrix4(Dt),Rt.b.applyMatrix4(Dt),Rt.c.applyMatrix4(Dt),Rt.needsUpdate=!0;for(let A=0,f=R.count;A<f;A+=3)if(V(lt,A,R,l),lt.needsUpdate=!0,Rt.intersectsTriangle(lt))return!0}}else{const C=r+8,T=o[r+6];return Y(C,E,qt),!!(s.intersectsBox(qt)&&me(C,n,t,e,s)||(Y(T,E,qt),s.intersectsBox(qt)&&me(T,n,t,e,s)))}}const Zt=new $,fe=new H,ht=new H,ni=new g,ii=new g,Ei=new g,oi=new g;function ri(r,n,t,e={},s={},E=0,i=1/0){n.boundingBox||n.computeBoundingBox(),fe.set(n.boundingBox.min,n.boundingBox.max,t),fe.needsUpdate=!0;const o=r.geometry,I=o.attributes.position,c=o.index,C=n.attributes.position,T=n.index,a=W.getPrimitive(),R=W.getPrimitive();let l=ni,S=ii,N=null,F=null;s&&(N=Ei,F=oi);let u=1/0,O=null,A=null;return Zt.copy(t).invert(),ht.matrix.copy(Zt),r.shapecast({boundsTraverseOrder:f=>fe.distanceToBox(f),intersectsBounds:(f,L,P)=>P<u&&P<i?(L&&(ht.min.copy(f.min),ht.max.copy(f.max),ht.needsUpdate=!0),!0):!1,intersectsRange:(f,L)=>{if(n.boundsTree){const P=n.boundsTree;return P.shapecast({boundsTraverseOrder:p=>ht.distanceToBox(p),intersectsBounds:(p,U,D)=>D<u&&D<i,intersectsRange:(p,U)=>{for(let D=p,y=p+U;D<y;D++){const d=P.resolveTriangleIndex(D);V(R,3*d,T,C),R.a.applyMatrix4(t),R.b.applyMatrix4(t),R.c.applyMatrix4(t),R.needsUpdate=!0;for(let h=f,m=f+L;h<m;h++){const w=r.resolveTriangleIndex(h);V(a,3*w,c,I),a.needsUpdate=!0;const G=a.distanceToTriangle(R,l,N);if(G<u&&(S.copy(l),F&&F.copy(N),u=G,O=h,A=D),G<E)return!0}}}})}else{const P=Nt(n);for(let p=0,U=P;p<U;p++){V(R,3*p,T,C),R.a.applyMatrix4(t),R.b.applyMatrix4(t),R.c.applyMatrix4(t),R.needsUpdate=!0;for(let D=f,y=f+L;D<y;D++){const d=r.resolveTriangleIndex(D);V(a,3*d,c,I),a.needsUpdate=!0;const h=a.distanceToTriangle(R,l,N);if(h<u&&(S.copy(l),F&&F.copy(N),u=h,O=D,A=p),h<E)return!0}}}}}),W.releasePrimitive(a),W.releasePrimitive(R),u===1/0?null:(e.point?e.point.copy(S):e.point=S.clone(),e.distance=u,e.faceIndex=O,s&&(s.point?s.point.copy(F):s.point=F.clone(),s.point.applyMatrix4(Zt),S.applyMatrix4(Zt),s.distance=S.sub(s.point).length(),s.faceIndex=A),e)}function Ii(){return typeof SharedArrayBuffer<"u"}const gt=new B.constructor,ee=new B.constructor,st=new Ve(()=>new q),Ft=new q,At=new q,Ne=new q,Oe=new q;let Se=!1;function ai(r,n,t,e){if(Se)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Se=!0;const s=r._roots,E=n._roots;let i,o=0,I=0;const c=new $().copy(t).invert();for(let C=0,T=s.length;C<T;C++){gt.setBuffer(s[C]),I=0;const a=st.getPrimitive();Y(0,gt.float32Array,a),a.applyMatrix4(c);for(let R=0,l=E.length;R<l&&(ee.setBuffer(E[C]),i=j(0,0,t,c,e,o,I,0,0,a),ee.clearBuffer(),I+=E[R].length,!i);R++);if(st.releasePrimitive(a),gt.clearBuffer(),o+=s[C].length,i)break}return Se=!1,i}function j(r,n,t,e,s,E=0,i=0,o=0,I=0,c=null,C=!1){let T,a;C?(T=ee,a=gt):(T=gt,a=ee);const R=T.float32Array,l=T.uint32Array,S=T.uint16Array,N=a.float32Array,F=a.uint32Array,u=a.uint16Array,O=r*2,A=n*2,f=v(O,S),L=v(A,u);let P=!1;if(L&&f)C?P=s(_(n,F),X(n*2,u),_(r,l),X(r*2,S),I,i+n,o,E+r):P=s(_(r,l),X(r*2,S),_(n,F),X(n*2,u),o,E+r,I,i+n);else if(L){const p=st.getPrimitive();Y(n,N,p),p.applyMatrix4(t);const U=z(r),D=k(r,l);Y(U,R,Ft),Y(D,R,At);const y=p.intersectsBox(Ft),d=p.intersectsBox(At);P=y&&j(n,U,e,t,s,i,E,I,o+1,p,!C)||d&&j(n,D,e,t,s,i,E,I,o+1,p,!C),st.releasePrimitive(p)}else{const p=z(n),U=k(n,F);Y(p,N,Ne),Y(U,N,Oe);const D=c.intersectsBox(Ne),y=c.intersectsBox(Oe);if(D&&y)P=j(r,p,t,e,s,E,i,o,I+1,c,C)||j(r,U,t,e,s,E,i,o,I+1,c,C);else if(D)if(f)P=j(r,p,t,e,s,E,i,o,I+1,c,C);else{const d=st.getPrimitive();d.copy(Ne).applyMatrix4(t);const h=z(r),m=k(r,l);Y(h,R,Ft),Y(m,R,At);const w=d.intersectsBox(Ft),G=d.intersectsBox(At);P=w&&j(p,h,e,t,s,i,E,I,o+1,d,!C)||G&&j(p,m,e,t,s,i,E,I,o+1,d,!C),st.releasePrimitive(d)}else if(y)if(f)P=j(r,U,t,e,s,E,i,o,I+1,c,C);else{const d=st.getPrimitive();d.copy(Oe).applyMatrix4(t);const h=z(r),m=k(r,l);Y(h,R,Ft),Y(m,R,At);const w=d.intersectsBox(Ft),G=d.intersectsBox(At);P=w&&j(U,h,e,t,s,i,E,I,o+1,d,!C)||G&&j(U,m,e,t,s,i,E,I,o+1,d,!C),st.releasePrimitive(d)}}return P}const Jt=new H,os=new q;class He{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,s=n._roots,E=n._indirectBuffer,i=e.getIndex();let o;return t.cloneBuffers?o={roots:s.map(I=>I.slice()),index:i.array.slice(),indirectBuffer:E?E.slice():null}:o={roots:s,index:i.array,indirectBuffer:E},o}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:s,roots:E,indirectBuffer:i}=n,o=new He(t,{...e,[Re]:!0});if(o._roots=E,o._indirectBuffer=i||null,e.setIndex){const I=t.getIndex();if(I===null){const c=new Bt(n.index,1,!1);t.setIndex(c)}else I.array!==s&&(I.array.set(s),I.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:Us,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Re]:!1},t),t.useSharedArrayBuffer&&!Ii())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Re]||(Mn(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new q)));const{_indirectBuffer:e}=this;this.resolveTriangleIndex=t.indirect?s=>e[s]:s=>s}refit(n=null){return(this.indirect?Zn:Vn)(this,n)}traverse(n,t=0){const e=this._roots[t],s=new Uint32Array(e),E=new Uint16Array(e);i(0);function i(o,I=0){const c=o*2,C=E[c+15]===Ce;if(C){const T=s[o+6],a=E[c+14];n(I,C,new Float32Array(e,o*4,6),T,a)}else{const T=o+te/4,a=s[o+6],R=s[o+7];n(I,C,new Float32Array(e,o*4,6),R)||(i(T,I+1),i(a,I+1))}}}raycast(n,t=_e){const e=this._roots,s=this.geometry,E=[],i=t.isMaterial,o=Array.isArray(t),I=s.groups,c=i?t.side:t,C=this.indirect?Jn:Wn;for(let T=0,a=e.length;T<a;T++){const R=o?t[I[T].materialIndex].side:c,l=E.length;if(C(this,T,R,n,E),o){const S=I[T].materialIndex;for(let N=l,F=E.length;N<F;N++)E[N].face.materialIndex=S}}return E}raycastFirst(n,t=_e){const e=this._roots,s=this.geometry,E=t.isMaterial,i=Array.isArray(t);let o=null;const I=s.groups,c=E?t.side:t,C=this.indirect?ei:zn;for(let T=0,a=e.length;T<a;T++){const R=i?t[I[T].materialIndex].side:c,l=C(this,T,R,n);l!=null&&(o==null||l.distance<o.distance)&&(o=l,i&&(l.face.materialIndex=I[T].materialIndex))}return o}intersectsGeometry(n,t){let e=!1;const s=this._roots,E=this.indirect?si:kn;for(let i=0,o=s.length;i<o&&(e=E(this,i,n,t),!e);i++);return e}shapecast(n){const t=W.getPrimitive(),e=this.indirect?_n:bn;let{boundsTraverseOrder:s,intersectsBounds:E,intersectsRange:i,intersectsTriangle:o}=n;if(i&&o){const T=i;i=(a,R,l,S,N)=>T(a,R,l,S,N)?!0:e(a,R,this,o,l,S,t)}else i||(o?i=(T,a,R,l)=>e(T,a,this,o,R,l,t):i=(T,a,R)=>R);let I=!1,c=0;const C=this._roots;for(let T=0,a=C.length;T<a;T++){const R=C[T];if(I=mn(this,T,E,i,s,c),I)break;c+=R.byteLength}return W.releasePrimitive(t),I}bvhcast(n,t,e){let{intersectsRanges:s,intersectsTriangles:E}=e;const i=W.getPrimitive(),o=this.geometry.index,I=this.geometry.attributes.position,c=this.indirect?l=>{const S=this.resolveTriangleIndex(l);V(i,S*3,o,I)}:l=>{V(i,l*3,o,I)},C=W.getPrimitive(),T=n.geometry.index,a=n.geometry.attributes.position,R=n.indirect?l=>{const S=n.resolveTriangleIndex(l);V(C,S*3,T,a)}:l=>{V(C,l*3,T,a)};if(E){const l=(S,N,F,u,O,A,f,L)=>{for(let P=F,p=F+u;P<p;P++){R(P),C.a.applyMatrix4(t),C.b.applyMatrix4(t),C.c.applyMatrix4(t),C.needsUpdate=!0;for(let U=S,D=S+N;U<D;U++)if(c(U),i.needsUpdate=!0,E(i,C,U,P,O,A,f,L))return!0}return!1};if(s){const S=s;s=function(N,F,u,O,A,f,L,P){return S(N,F,u,O,A,f,L,P)?!0:l(N,F,u,O,A,f,L,P)}}else s=l}return ai(this,n,t,s)}intersectsBox(n,t){return Jt.set(n.min,n.max,t),Jt.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Jt.intersectsBox(e),intersectsTriangle:e=>Jt.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},s={},E=0,i=1/0){return(this.indirect?ri:Qn)(this,n,t,e,s,E,i)}closestPointToPoint(n,t={},e=0,s=1/0){return wn(this,n,t,e,s)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{Y(0,new Float32Array(e),os),n.union(os)}),n}}function rs(r,n,t){return r===null||(r.point.applyMatrix4(n.matrixWorld),r.distance=r.point.distanceTo(t.ray.origin),r.object=n,r.distance<t.near||r.distance>t.far)?null:r}const Le=new vs,Is=new $,Ci=cs.prototype.raycast;function ci(r,n){if(this.geometry.boundsTree){if(this.material===void 0)return;Is.copy(this.matrixWorld).invert(),Le.copy(r.ray).applyMatrix4(Is);const t=this.geometry.boundsTree;if(r.firstHitOnly===!0){const e=rs(t.raycastFirst(Le,this.material),this,r);e&&n.push(e)}else{const e=t.raycast(Le,this.material);for(let s=0,E=e.length;s<E;s++){const i=rs(e[s],this,r);i&&n.push(i)}}}else Ci.call(this,r,n)}function Ti(r){return this.boundsTree=new He(this,r),this.boundsTree}function Ri(){this.boundsTree=null}class x{constructor(){M(this,"trigger",n=>{const t=this.handlers.slice(0);for(const e of t)e(n)});M(this,"handlers",[])}add(n){this.handlers.push(n)}remove(n){this.handlers=this.handlers.filter(t=>t!==n)}reset(){this.handlers.length=0}}class li{constructor(n){M(this,"isDisposeable",()=>"dispose"in this&&"onDisposed"in this);M(this,"isResizeable",()=>"resize"in this&&"getSize"in this);M(this,"isUpdateable",()=>"onAfterUpdate"in this&&"onBeforeUpdate"in this&&"update"in this);M(this,"isHideable",()=>"visible"in this);M(this,"isConfigurable",()=>"setup"in this&&"config"in this&&"onSetup"in this);this.components=n}}class Gt extends li{}class as extends Map{constructor(t){super(t);M(this,"onItemSet",new x);M(this,"onItemUpdated",new x);M(this,"onItemDeleted",new x);M(this,"onCleared",new x)}clear(){super.clear(),this.onCleared.trigger()}set(t,e){const s=this.has(t),E=super.set(t,e);return s?(this.onItemUpdated||(this.onItemUpdated=new x),this.onItemUpdated.trigger({key:t,value:e})):(this.onItemSet||(this.onItemSet=new x),this.onItemSet.trigger({key:t,value:e})),E}delete(t){const e=super.delete(t);return e&&this.onItemDeleted.trigger(),e}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onCleared.reset()}}const b=class b{static create(){const n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return`${b._lut[n&255]+b._lut[n>>8&255]+b._lut[n>>16&255]+b._lut[n>>24&255]}-${b._lut[t&255]}${b._lut[t>>8&255]}-${b._lut[t>>16&15|64]}${b._lut[t>>24&255]}-${b._lut[e&63|128]}${b._lut[e>>8&255]}-${b._lut[e>>16&255]}${b._lut[e>>24&255]}${b._lut[s&255]}${b._lut[s>>8&255]}${b._lut[s>>16&255]}${b._lut[s>>24&255]}`.toLowerCase()}static validate(n){if(!b._pattern.test(n))throw new Error(`${n} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`)}};M(b,"_pattern",/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/),M(b,"_lut",["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"]);let se=b;const re=class re{constructor(){M(this,"onDisposed",new x);M(this,"list",new Map);M(this,"enabled",!1);M(this,"_clock");M(this,"update",()=>{if(!this.enabled)return;const n=this._clock.getDelta();for(const[t,e]of this.list)e.enabled&&e.isUpdateable()&&e.update(n);requestAnimationFrame(this.update)});this._clock=new _s,re.setupBVH()}add(n,t){if(this.list.has(n))throw new Error("You're trying to add a component that already exists in the components instance. Use Components.get() instead.");se.validate(n),this.list.set(n,t)}get(n){const t=n.uuid;if(!this.list.has(t)){const e=new n(this);return this.list.has(t)||this.add(t,e),e}return this.list.get(t)}init(){this.enabled=!0,this._clock.start(),this.update()}dispose(){this.enabled=!1;for(const[n,t]of this.list)t.enabled=!1,t.isDisposeable()&&t.dispose();this._clock.stop(),this.onDisposed.trigger(),this.onDisposed.reset()}static setupBVH(){pe.prototype.computeBoundsTree=Ti,pe.prototype.disposeBoundsTree=Ri,cs.prototype.raycast=ci}};M(re,"release","2.1.26");let ne=re;const Fi=new Map([[Ye,{forRelated:"Decomposes",forRelating:"IsDecomposedBy"}],[Ts,{forRelated:"HasAssociations",forRelating:"AssociatedTo"}],[Rs,{forRelated:"HasAssociations",forRelating:"ClassificationForObjects"}],[ls,{forRelated:"HasAssignments",forRelating:"IsGroupedBy"}],[xe,{forRelated:"IsDefinedBy",forRelating:"DefinesOcurrence"}],[Fs,{forRelated:"IsTypedBy",forRelating:"Types"}],[As,{forRelated:"IsDefinedBy",forRelating:"Defines"}],[Ge,{forRelated:"ContainedInStructure",forRelating:"ContainsElements"}],[us,{forRelated:"AssignedToFlowElement",forRelating:"HasControlElements"}],[fs,{forRelated:"ConnectedFrom",forRelating:"ConnectedTo"}],[Ns,{forRelated:"HasAssignments",forRelating:"ReferencedBy"}],[Os,{forRelated:"HasContext",forRelating:"Declares"}],[Ss,{forRelated:"HasAssignments",forRelating:"Controls"}],[Ls,{forRelated:"Nests",forRelating:"IsNestedBy"}]]),mt=class mt extends Gt{constructor(t){super(t);M(this,"onDisposed",new x);M(this,"onRelationsIndexed",new x);M(this,"relationMaps",{});M(this,"enabled",!0);M(this,"_relToAttributesMap",Fi);M(this,"_inverseAttributes",["IsDecomposedBy","Decomposes","AssociatedTo","HasAssociations","ClassificationForObjects","IsGroupedBy","HasAssignments","IsDefinedBy","DefinesOcurrence","IsTypedBy","Types","Defines","ContainedInStructure","ContainsElements","HasControlElements","AssignedToFlowElement","ConnectedTo","ConnectedFrom","ReferencedBy","Declares","HasContext","Controls","IsNestedBy","Nests"]);M(this,"_ifcRels",[Ye,Ts,Rs,ls,xe,Fs,As,Ge,us,fs,Ns,Os,Ss,Ls]);M(this,"onFragmentsDisposed",t=>{delete this.relationMaps[t.groupID]});this.components.add(mt.uuid,this),t.get(Yt).onFragmentsDisposed.add(this.onFragmentsDisposed)}indexRelations(t,e,s,E){const i=Object.keys(e).find(a=>a.startsWith("Relating")),o=Object.keys(e).find(a=>a.startsWith("Related"));if(!(i&&o))return;const I=e[i].value,c=e[o].map(a=>a.value),C=t.get(I)??new Map,T=this.getAttributeIndex(E);T!==null&&(C.set(T,c),t.set(I,C));for(const a of c){const R=t.get(a)??new Map,l=this.getAttributeIndex(s);if(!l)continue;const S=R.get(l)??[];S.push(I),R.set(l,S),t.set(a,R)}}getAttributeIndex(t){const e=this._inverseAttributes.indexOf(t);return e===-1?null:e}setRelationMap(t,e){this.relationMaps[t.uuid]=e,this.onRelationsIndexed.trigger({modelID:t.uuid,relationsMap:e})}async process(t){if(!t.hasProperties)throw new Error("FragmentsGroup properties not found");let e=this.relationMaps[t.uuid];if(e)return e;e=new Map;for(const s of this._ifcRels){const E=await t.getAllPropertiesOfType(s);if(!E)continue;const i=this._relToAttributesMap.get(s);if(!i)continue;const{forRelated:o,forRelating:I}=i;for(const c in E){const C=E[c];this.indexRelations(e,C,o,I)}}return this.setRelationMap(t,e),e}async processFromWebIfc(t,e){const s=new Map;for(const E of this._ifcRels){const i=this._relToAttributesMap.get(E);if(!i)continue;const{forRelated:o,forRelating:I}=i,c=t.GetLineIDsWithType(e,E);for(let C=0;C<c.size();C++){const T=await t.properties.getItemProperties(e,c.get(C));this.indexRelations(s,T,o,I)}}return this.onRelationsIndexed.trigger({modelID:e.toString(),relationsMap:s}),s}getEntityRelations(t,e,s){const E=this.relationMaps[t.uuid];if(!E)throw new Error(`IfcRelationsIndexer: model ${t.uuid} has no relations indexed.`);const i=E.get(e),o=this.getAttributeIndex(s);if(i===void 0||o===null)return null;const I=i.get(o);return I||null}serializeRelations(t){const e={};for(const[s,E]of t.entries()){e[s]||(e[s]={});for(const[i,o]of E.entries())e[s][i]=o}return JSON.stringify(e)}serializeModelRelations(t){const e=this.relationMaps[t.uuid];return e?this.serializeRelations(e):null}serializeAllRelations(){const t={};for(const e in this.relationMaps){const s=this.relationMaps[e],E={};for(const[i,o]of s.entries()){E[i]||(E[i]={});for(const[I,c]of o.entries())E[i][I]=c}t[e]=E}return JSON.stringify(t)}getRelationsMapFromJSON(t){const e=JSON.parse(t),s=new Map;for(const E in e){const i=e[E],o=new Map;for(const I in i)o.set(Number(I),i[I]);s.set(Number(E),o)}return s}dispose(){this.relationMaps={},this.components.get(Yt).onFragmentsDisposed.remove(this.onFragmentsDisposed),this.onDisposed.trigger(mt.uuid),this.onDisposed.reset()}getEntitiesWithRelation(t,e,s){const E=this.relationMaps[t.uuid];if(!E)throw new Error("IfcRelationsIndexer: the model relations are not indexed!");const i=new Set;for(const[o,I]of E){const c=this.getAttributeIndex(e);if(c===null)throw new Error("IfcRelationsIndexer: invalid inverse attribute name");const C=I.get(c);C&&C.includes(s)&&i.add(o)}return i}addEntityRelations(t,e,s,...E){const i=this.getEntityRelations(t,e,s);if(i)i.push(...E);else{const o=this.getAttributeIndex(s);if(!o)throw new Error(`IfcRelationsIndexer: ${s} is not a valid relation name.`);const I=this.relationMaps[t.uuid].get(e);I==null||I.set(o,E)}}getEntityChildren(t,e,s=new Set){if(s.add(e),this.relationMaps[t.uuid]===void 0)throw new Error("The provided model has no indices. You have to generate them first.");const i=this.getEntityRelations(t,e,"IsDecomposedBy");if(i)for(const I of i)this.getEntityChildren(t,I,s);const o=this.getEntityRelations(t,e,"ContainsElements");if(o)for(const I of o)this.getEntityChildren(t,I,s);return s}};M(mt,"uuid","23a889ab-83b3-44a4-8bee-ead83438370b");let ie=mt;const Ie=class Ie extends Gt{constructor(t){super(t);M(this,"onDisposed",new x);M(this,"onFragmentsLoaded",new x);M(this,"onFragmentsDisposed",new x);M(this,"list",new as);M(this,"groups",new as);M(this,"baseCoordinationModel","");M(this,"baseCoordinationMatrix",new $);M(this,"enabled",!0);M(this,"_loader",new Ws);this.components.add(Ie.uuid,this)}get meshes(){const t=[];for(const[e,s]of this.list)t.push(s.mesh);return t}dispose(){for(const[t,e]of this.groups)e.dispose(!0);this.baseCoordinationModel="",this.groups.clear(),this.list.clear(),this.onFragmentsLoaded.reset(),this.onFragmentsDisposed.reset(),this.onDisposed.trigger(),this.onDisposed.reset()}disposeGroup(t){const{uuid:e}=t,s=[];for(const E of t.items)s.push(E.id),this.list.delete(E.id);t.dispose(!0),this.groups.delete(t.uuid),this.onFragmentsDisposed.trigger({groupID:e,fragmentIDs:s})}load(t,e){const E={...{coordinate:!0},...e},{coordinate:i,name:o,properties:I,relationsMap:c}=E,C=this._loader.import(t);e&&(C.isStreamed=e.isStreamed||!1),o&&(C.name=o);for(const T of C.items)T.group=C,this.list.set(T.id,T);return i&&this.coordinate([C]),this.groups.set(C.uuid,C),I&&C.setLocalProperties(I),c&&this.components.get(ie).setRelationMap(C,c),this.onFragmentsLoaded.trigger(C),C}export(t){return this._loader.export(t)}getModelIdMap(t){const e={};for(const s in t){const E=this.list.get(s);if(!(E&&E.group))continue;const i=E.group;i.uuid in e||(e[i.uuid]=new Set);const o=t[s];for(const I of o)e[i.uuid].add(I)}return e}modelIdToFragmentIdMap(t){let e={};for(const s in t){const E=this.groups.get(s);if(!E)continue;const i=t[s],o=E.getFragmentMap(i);e={...e,...o}}return e}coordinate(t=Array.from(this.groups.values())){if(this.baseCoordinationModel.length===0){const s=t.pop();if(!s)return;this.baseCoordinationModel=s.uuid,this.baseCoordinationMatrix=s.coordinationMatrix.clone()}if(t.length)for(const s of t)s.coordinationMatrix.equals(this.baseCoordinationMatrix)||(s.position.set(0,0,0),s.rotation.set(0,0,0),s.scale.set(1,1,1),s.updateMatrix(),this.applyBaseCoordinateSystem(s,s.coordinationMatrix))}applyBaseCoordinateSystem(t,e){t.applyMatrix4(e.clone().invert()),t.applyMatrix4(this.baseCoordinationMatrix)}clone(t,e){const s=t.cloneGroup(e);this.groups.set(s.uuid,s);for(const E of s.items)this.list.set(E.id,E);return s}};M(Ie,"uuid","fef46874-46a3-461b-8c44-2922ab77c806");let Yt=Ie;const Ai=new Set([1123145078,574549367,1675464909,2059837836,3798115385,32440307,3125803723,3207858831,2740243338,2624227202,4240577450,3615266464,3724593414,220341763,477187591,1878645084,1300840506,3303107099,1607154358,1878645084,846575682,1351298697,2417041796,3049322572,3331915920,1416205885,776857604,3285139300,3958052878,2827736869,2732653382,673634403,3448662350,4142052618,2924175390,803316827,2556980723,1809719519,2205249479,807026263,3737207727,1660063152,2347385850,2705031697,3732776249,2485617015,2611217952,1704287377,2937912522,2770003689,1281925730,1484403080,3448662350,4142052618,3800577675,4006246654,3590301190,1383045692,2775532180,2047409740,370225590,3593883385,2665983363,4124623270,812098782,3649129432,987898635,1105321065,3510044353,1635779807,2603310189,3406155212,1310608509,4261334040,2736907675,3649129432,1136057603,1260505505,4182860854,2713105998,2898889636,59481748,3749851601,3486308946,3150382593,1062206242,3264961684,15328376,1485152156,370225590,1981873012,2859738748,45288368,2614616156,2732653382,775493141,2147822146,2601014836,2629017746,1186437898,2367409068,1213902940,3632507154,3900360178,476780140,1472233963,2804161546,3008276851,738692330,374418227,315944413,3905492369,3570813810,2571569899,178912537,2294589976,1437953363,2133299955,572779678,3092502836,388784114,2624227202,1425443689,3057273783,2347385850,1682466193,2519244187,2839578677,3958567839,2513912981,2830218821,427810014]),ae=class ae extends Gt{constructor(t){super(t);M(this,"enabled",!0);t.add(ae.uuid,this)}async export(t,e,s=!1,E=!0){const i={},o=new Set(t.GetIfcEntityList(e)),I=new Set([Ps,ps,ds,Ms,xt]);for(const c of I)o.add(c);for(const c of o){if(Ai.has(c))continue;const C=I.has(c)&&E,T=t.GetLineIDsWithType(e,c);for(const a of T){const R=t.GetLine(0,a,C,s);i[R.expressID]=R}}return i}};M(ae,"uuid","b32c4332-cd67-436e-ba7f-196646c7a635");let we=ae;const ui={950732822:"IFCURIREFERENCE",4075327185:"IFCTIME",1209108979:"IFCTEMPERATURERATEOFCHANGEMEASURE",3457685358:"IFCSOUNDPRESSURELEVELMEASURE",4157543285:"IFCSOUNDPOWERLEVELMEASURE",2798247006:"IFCPROPERTYSETDEFINITIONSET",1790229001:"IFCPOSITIVEINTEGER",525895558:"IFCNONNEGATIVELENGTHMEASURE",1774176899:"IFCLINEINDEX",1275358634:"IFCLANGUAGEID",2541165894:"IFCDURATION",3701338814:"IFCDAYINWEEKNUMBER",2195413836:"IFCDATETIME",937566702:"IFCDATE",1683019596:"IFCCARDINALPOINTREFERENCE",2314439260:"IFCBINARY",1500781891:"IFCAREADENSITYMEASURE",3683503648:"IFCARCINDEX",4065007721:"IFCYEARNUMBER",1718600412:"IFCWARPINGMOMENTMEASURE",51269191:"IFCWARPINGCONSTANTMEASURE",2593997549:"IFCVOLUMETRICFLOWRATEMEASURE",3458127941:"IFCVOLUMEMEASURE",3345633955:"IFCVAPORPERMEABILITYMEASURE",1278329552:"IFCTORQUEMEASURE",2591213694:"IFCTIMESTAMP",2726807636:"IFCTIMEMEASURE",743184107:"IFCTHERMODYNAMICTEMPERATUREMEASURE",2016195849:"IFCTHERMALTRANSMITTANCEMEASURE",857959152:"IFCTHERMALRESISTANCEMEASURE",2281867870:"IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",2645777649:"IFCTHERMALCONDUCTIVITYMEASURE",232962298:"IFCTHERMALADMITTANCEMEASURE",296282323:"IFCTEXTTRANSFORMATION",603696268:"IFCTEXTFONTNAME",3490877962:"IFCTEXTDECORATION",1460886941:"IFCTEXTALIGNMENT",2801250643:"IFCTEXT",58845555:"IFCTEMPERATUREGRADIENTMEASURE",361837227:"IFCSPECULARROUGHNESS",2757832317:"IFCSPECULAREXPONENT",3477203348:"IFCSPECIFICHEATCAPACITYMEASURE",993287707:"IFCSOUNDPRESSUREMEASURE",846465480:"IFCSOUNDPOWERMEASURE",3471399674:"IFCSOLIDANGLEMEASURE",408310005:"IFCSHEARMODULUSMEASURE",2190458107:"IFCSECTIONALAREAINTEGRALMEASURE",3467162246:"IFCSECTIONMODULUSMEASURE",2766185779:"IFCSECONDINMINUTE",3211557302:"IFCROTATIONALSTIFFNESSMEASURE",1755127002:"IFCROTATIONALMASSMEASURE",2133746277:"IFCROTATIONALFREQUENCYMEASURE",200335297:"IFCREAL",96294661:"IFCRATIOMEASURE",3972513137:"IFCRADIOACTIVITYMEASURE",3665567075:"IFCPRESSUREMEASURE",2169031380:"IFCPRESENTABLETEXT",1364037233:"IFCPOWERMEASURE",1245737093:"IFCPOSITIVERATIOMEASURE",3054510233:"IFCPOSITIVEPLANEANGLEMEASURE",2815919920:"IFCPOSITIVELENGTHMEASURE",4042175685:"IFCPLANEANGLEMEASURE",2642773653:"IFCPLANARFORCEMEASURE",2260317790:"IFCPARAMETERVALUE",929793134:"IFCPHMEASURE",2395907400:"IFCNUMERICMEASURE",2095195183:"IFCNORMALISEDRATIOMEASURE",765770214:"IFCMONTHINYEARNUMBER",2615040989:"IFCMONETARYMEASURE",3114022597:"IFCMOMENTOFINERTIAMEASURE",1648970520:"IFCMOLECULARWEIGHTMEASURE",3177669450:"IFCMOISTUREDIFFUSIVITYMEASURE",1753493141:"IFCMODULUSOFSUBGRADEREACTIONMEASURE",1052454078:"IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",2173214787:"IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",3341486342:"IFCMODULUSOFELASTICITYMEASURE",102610177:"IFCMINUTEINHOUR",3531705166:"IFCMASSPERLENGTHMEASURE",3124614049:"IFCMASSMEASURE",4017473158:"IFCMASSFLOWRATEMEASURE",1477762836:"IFCMASSDENSITYMEASURE",2486716878:"IFCMAGNETICFLUXMEASURE",286949696:"IFCMAGNETICFLUXDENSITYMEASURE",151039812:"IFCLUMINOUSINTENSITYMEASURE",2755797622:"IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",2095003142:"IFCLUMINOUSFLUXMEASURE",503418787:"IFCLOGICAL",3086160713:"IFCLINEARVELOCITYMEASURE",1307019551:"IFCLINEARSTIFFNESSMEASURE",2128979029:"IFCLINEARMOMENTMEASURE",191860431:"IFCLINEARFORCEMEASURE",1243674935:"IFCLENGTHMEASURE",3258342251:"IFCLABEL",2054016361:"IFCKINEMATICVISCOSITYMEASURE",3192672207:"IFCISOTHERMALMOISTURECAPACITYMEASURE",3686016028:"IFCIONCONCENTRATIONMEASURE",3809634241:"IFCINTEGERCOUNTRATEMEASURE",1939436016:"IFCINTEGER",2679005408:"IFCINDUCTANCEMEASURE",3358199106:"IFCILLUMINANCEMEASURE",983778844:"IFCIDENTIFIER",2589826445:"IFCHOURINDAY",1158859006:"IFCHEATINGVALUEMEASURE",3113092358:"IFCHEATFLUXDENSITYMEASURE",3064340077:"IFCGLOBALLYUNIQUEID",3044325142:"IFCFREQUENCYMEASURE",1361398929:"IFCFORCEMEASURE",2590844177:"IFCFONTWEIGHT",2715512545:"IFCFONTVARIANT",1102727119:"IFCFONTSTYLE",2078135608:"IFCENERGYMEASURE",2506197118:"IFCELECTRICVOLTAGEMEASURE",2951915441:"IFCELECTRICRESISTANCEMEASURE",3790457270:"IFCELECTRICCURRENTMEASURE",2093906313:"IFCELECTRICCONDUCTANCEMEASURE",3818826038:"IFCELECTRICCHARGEMEASURE",1827137117:"IFCELECTRICCAPACITANCEMEASURE",69416015:"IFCDYNAMICVISCOSITYMEASURE",524656162:"IFCDOSEEQUIVALENTMEASURE",4134073009:"IFCDIMENSIONCOUNT",1514641115:"IFCDESCRIPTIVEMEASURE",300323983:"IFCDAYLIGHTSAVINGHOUR",86635668:"IFCDAYINMONTHNUMBER",94842927:"IFCCURVATUREMEASURE",1778710042:"IFCCOUNTMEASURE",3238673880:"IFCCONTEXTDEPENDENTMEASURE",3812528620:"IFCCOMPOUNDPLANEANGLEMEASURE",2991860651:"IFCCOMPLEXNUMBER",1867003952:"IFCBOXALIGNMENT",2735952531:"IFCBOOLEAN",2650437152:"IFCAREAMEASURE",632304761:"IFCANGULARVELOCITYMEASURE",360377573:"IFCAMOUNTOFSUBSTANCEMEASURE",4182062534:"IFCACCELERATIONMEASURE",3699917729:"IFCABSORBEDDOSEMEASURE",1971632696:"IFCGEOSLICE",2680139844:"IFCGEOMODEL",24726584:"IFCELECTRICFLOWTREATMENTDEVICE",3693000487:"IFCDISTRIBUTIONBOARD",3460952963:"IFCCONVEYORSEGMENT",3999819293:"IFCCAISSONFOUNDATION",3314249567:"IFCBOREHOLE",4196446775:"IFCBEARING",325726236:"IFCALIGNMENT",3425753595:"IFCTRACKELEMENT",991950508:"IFCSIGNAL",3798194928:"IFCREINFORCEDSOIL",3290496277:"IFCRAIL",1383356374:"IFCPAVEMENT",2182337498:"IFCNAVIGATIONELEMENT",234836483:"IFCMOORINGDEVICE",2078563270:"IFCMOBILETELECOMMUNICATIONSAPPLIANCE",1638804497:"IFCLIQUIDTERMINAL",1154579445:"IFCLINEARPOSITIONINGELEMENT",2696325953:"IFCKERB",2713699986:"IFCGEOTECHNICALASSEMBLY",2142170206:"IFCELECTRICFLOWTREATMENTDEVICETYPE",3376911765:"IFCEARTHWORKSFILL",1077100507:"IFCEARTHWORKSELEMENT",3071239417:"IFCEARTHWORKSCUT",479945903:"IFCDISTRIBUTIONBOARDTYPE",3426335179:"IFCDEEPFOUNDATION",1502416096:"IFCCOURSE",2940368186:"IFCCONVEYORSEGMENTTYPE",3203706013:"IFCCAISSONFOUNDATIONTYPE",3862327254:"IFCBUILTSYSTEM",1876633798:"IFCBUILTELEMENT",963979645:"IFCBRIDGEPART",644574406:"IFCBRIDGE",3649138523:"IFCBEARINGTYPE",1662888072:"IFCALIGNMENTVERTICAL",317615605:"IFCALIGNMENTSEGMENT",1545765605:"IFCALIGNMENTHORIZONTAL",4266260250:"IFCALIGNMENTCANT",3956297820:"IFCVIBRATIONDAMPERTYPE",1530820697:"IFCVIBRATIONDAMPER",840318589:"IFCVEHICLE",1953115116:"IFCTRANSPORTATIONDEVICE",618700268:"IFCTRACKELEMENTTYPE",2281632017:"IFCTENDONCONDUITTYPE",3663046924:"IFCTENDONCONDUIT",42703149:"IFCSINESPIRAL",1894708472:"IFCSIGNALTYPE",3599934289:"IFCSIGNTYPE",33720170:"IFCSIGN",1027922057:"IFCSEVENTHORDERPOLYNOMIALSPIRAL",544395925:"IFCSEGMENTEDREFERENCECURVE",3649235739:"IFCSECONDORDERPOLYNOMIALSPIRAL",550521510:"IFCROADPART",146592293:"IFCROAD",3818125796:"IFCRELADHERESTOELEMENT",4021432810:"IFCREFERENT",1891881377:"IFCRAILWAYPART",3992365140:"IFCRAILWAY",1763565496:"IFCRAILTYPE",1946335990:"IFCPOSITIONINGELEMENT",514975943:"IFCPAVEMENTTYPE",506776471:"IFCNAVIGATIONELEMENTTYPE",710110818:"IFCMOORINGDEVICETYPE",1950438474:"IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",976884017:"IFCMARINEPART",525669439:"IFCMARINEFACILITY",1770583370:"IFCLIQUIDTERMINALTYPE",2176059722:"IFCLINEARELEMENT",679976338:"IFCKERBTYPE",3948183225:"IFCIMPACTPROTECTIONDEVICETYPE",2568555532:"IFCIMPACTPROTECTIONDEVICE",2898700619:"IFCGRADIENTCURVE",1594536857:"IFCGEOTECHNICALSTRATUM",4230923436:"IFCGEOTECHNICALELEMENT",4228831410:"IFCFACILITYPARTCOMMON",1310830890:"IFCFACILITYPART",24185140:"IFCFACILITY",4234616927:"IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",1306400036:"IFCDEEPFOUNDATIONTYPE",4189326743:"IFCCOURSETYPE",2000195564:"IFCCOSINESPIRAL",3497074424:"IFCCLOTHOID",1626504194:"IFCBUILTELEMENTTYPE",3651464721:"IFCVEHICLETYPE",1229763772:"IFCTRIANGULATEDIRREGULARNETWORK",3665877780:"IFCTRANSPORTATIONDEVICETYPE",782932809:"IFCTHIRDORDERPOLYNOMIALSPIRAL",2735484536:"IFCSPIRAL",1356537516:"IFCSECTIONEDSURFACE",1290935644:"IFCSECTIONEDSOLIDHORIZONTAL",1862484736:"IFCSECTIONEDSOLID",1441486842:"IFCRELPOSITIONS",1033248425:"IFCRELASSOCIATESPROFILEDEF",3381221214:"IFCPOLYNOMIALCURVE",2485787929:"IFCOFFSETCURVEBYDISTANCES",590820931:"IFCOFFSETCURVE",3465909080:"IFCINDEXEDPOLYGONALTEXTUREMAP",593015953:"IFCDIRECTRIXCURVESWEPTAREASOLID",4212018352:"IFCCURVESEGMENT",3425423356:"IFCAXIS2PLACEMENTLINEAR",823603102:"IFCSEGMENT",2165702409:"IFCPOINTBYDISTANCEEXPRESSION",182550632:"IFCOPENCROSSPROFILEDEF",388784114:"IFCLINEARPLACEMENT",536804194:"IFCALIGNMENTHORIZONTALSEGMENT",3752311538:"IFCALIGNMENTCANTSEGMENT",1010789467:"IFCTEXTURECOORDINATEINDICESWITHVOIDS",222769930:"IFCTEXTURECOORDINATEINDICES",2691318326:"IFCQUANTITYNUMBER",3633395639:"IFCALIGNMENTVERTICALSEGMENT",2879124712:"IFCALIGNMENTPARAMETERSEGMENT",25142252:"IFCCONTROLLER",3087945054:"IFCALARM",4288193352:"IFCACTUATOR",630975310:"IFCUNITARYCONTROLELEMENT",4086658281:"IFCSENSOR",2295281155:"IFCPROTECTIVEDEVICETRIPPINGUNIT",182646315:"IFCFLOWINSTRUMENT",1426591983:"IFCFIRESUPPRESSIONTERMINAL",819412036:"IFCFILTER",3415622556:"IFCFAN",1003880860:"IFCELECTRICTIMECONTROL",402227799:"IFCELECTRICMOTOR",264262732:"IFCELECTRICGENERATOR",3310460725:"IFCELECTRICFLOWSTORAGEDEVICE",862014818:"IFCELECTRICDISTRIBUTIONBOARD",1904799276:"IFCELECTRICAPPLIANCE",1360408905:"IFCDUCTSILENCER",3518393246:"IFCDUCTSEGMENT",342316401:"IFCDUCTFITTING",562808652:"IFCDISTRIBUTIONCIRCUIT",4074379575:"IFCDAMPER",3640358203:"IFCCOOLINGTOWER",4136498852:"IFCCOOLEDBEAM",2272882330:"IFCCONDENSER",3571504051:"IFCCOMPRESSOR",3221913625:"IFCCOMMUNICATIONSAPPLIANCE",639361253:"IFCCOIL",3902619387:"IFCCHILLER",4217484030:"IFCCABLESEGMENT",1051757585:"IFCCABLEFITTING",3758799889:"IFCCABLECARRIERSEGMENT",635142910:"IFCCABLECARRIERFITTING",2938176219:"IFCBURNER",32344328:"IFCBOILER",2906023776:"IFCBEAMSTANDARDCASE",277319702:"IFCAUDIOVISUALAPPLIANCE",2056796094:"IFCAIRTOAIRHEATRECOVERY",177149247:"IFCAIRTERMINALBOX",1634111441:"IFCAIRTERMINAL",486154966:"IFCWINDOWSTANDARDCASE",4237592921:"IFCWASTETERMINAL",4156078855:"IFCWALLELEMENTEDCASE",4207607924:"IFCVALVE",4292641817:"IFCUNITARYEQUIPMENT",3179687236:"IFCUNITARYCONTROLELEMENTTYPE",3026737570:"IFCTUBEBUNDLE",3825984169:"IFCTRANSFORMER",812556717:"IFCTANK",1162798199:"IFCSWITCHINGDEVICE",385403989:"IFCSTRUCTURALLOADCASE",1404847402:"IFCSTACKTERMINAL",1999602285:"IFCSPACEHEATER",3420628829:"IFCSOLARDEVICE",3027962421:"IFCSLABSTANDARDCASE",3127900445:"IFCSLABELEMENTEDCASE",1329646415:"IFCSHADINGDEVICE",3053780830:"IFCSANITARYTERMINAL",2572171363:"IFCREINFORCINGBARTYPE",1232101972:"IFCRATIONALBSPLINECURVEWITHKNOTS",90941305:"IFCPUMP",655969474:"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",738039164:"IFCPROTECTIVEDEVICE",1156407060:"IFCPLATESTANDARDCASE",3612865200:"IFCPIPESEGMENT",310824031:"IFCPIPEFITTING",3694346114:"IFCOUTLET",144952367:"IFCOUTERBOUNDARYCURVE",2474470126:"IFCMOTORCONNECTION",1911478936:"IFCMEMBERSTANDARDCASE",1437502449:"IFCMEDICALDEVICE",629592764:"IFCLIGHTFIXTURE",76236018:"IFCLAMP",2176052936:"IFCJUNCTIONBOX",4175244083:"IFCINTERCEPTOR",2068733104:"IFCHUMIDIFIER",3319311131:"IFCHEATEXCHANGER",2188021234:"IFCFLOWMETER",1209101575:"IFCEXTERNALSPATIALELEMENT",484807127:"IFCEVAPORATOR",3747195512:"IFCEVAPORATIVECOOLER",2814081492:"IFCENGINE",2417008758:"IFCELECTRICDISTRIBUTIONBOARDTYPE",3242481149:"IFCDOORSTANDARDCASE",3205830791:"IFCDISTRIBUTIONSYSTEM",400855858:"IFCCOMMUNICATIONSAPPLIANCETYPE",905975707:"IFCCOLUMNSTANDARDCASE",1677625105:"IFCCIVILELEMENT",3296154744:"IFCCHIMNEY",2674252688:"IFCCABLEFITTINGTYPE",2188180465:"IFCBURNERTYPE",1177604601:"IFCBUILDINGSYSTEM",39481116:"IFCBUILDINGELEMENTPARTTYPE",1136057603:"IFCBOUNDARYCURVE",2461110595:"IFCBSPLINECURVEWITHKNOTS",1532957894:"IFCAUDIOVISUALAPPLIANCETYPE",4088093105:"IFCWORKCALENDAR",4009809668:"IFCWINDOWTYPE",926996030:"IFCVOIDINGFEATURE",2391383451:"IFCVIBRATIONISOLATOR",2415094496:"IFCTENDONTYPE",3081323446:"IFCTENDONANCHORTYPE",413509423:"IFCSYSTEMFURNITUREELEMENT",3101698114:"IFCSURFACEFEATURE",3657597509:"IFCSTRUCTURALSURFACEACTION",2757150158:"IFCSTRUCTURALCURVEREACTION",1004757350:"IFCSTRUCTURALCURVEACTION",338393293:"IFCSTAIRTYPE",1072016465:"IFCSOLARDEVICETYPE",4074543187:"IFCSHADINGDEVICETYPE",2157484638:"IFCSEAMCURVE",2781568857:"IFCROOFTYPE",2310774935:"IFCREINFORCINGMESHTYPE",964333572:"IFCREINFORCINGELEMENTTYPE",683857671:"IFCRATIONALBSPLINESURFACEWITHKNOTS",1469900589:"IFCRAMPTYPE",2839578677:"IFCPOLYGONALFACESET",1158309216:"IFCPILETYPE",3079942009:"IFCOPENINGSTANDARDCASE",1114901282:"IFCMEDICALDEVICETYPE",3113134337:"IFCINTERSECTIONCURVE",3946677679:"IFCINTERCEPTORTYPE",2571569899:"IFCINDEXEDPOLYCURVE",3493046030:"IFCGEOGRAPHICELEMENT",1509553395:"IFCFURNITURE",1893162501:"IFCFOOTINGTYPE",2853485674:"IFCEXTERNALSPATIALSTRUCTUREELEMENT",4148101412:"IFCEVENT",132023988:"IFCENGINETYPE",2397081782:"IFCELEMENTASSEMBLYTYPE",2323601079:"IFCDOORTYPE",1213902940:"IFCCYLINDRICALSURFACE",1525564444:"IFCCONSTRUCTIONPRODUCTRESOURCETYPE",4105962743:"IFCCONSTRUCTIONMATERIALRESOURCETYPE",2185764099:"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",15328376:"IFCCOMPOSITECURVEONSURFACE",3875453745:"IFCCOMPLEXPROPERTYTEMPLATE",3893394355:"IFCCIVILELEMENTTYPE",2197970202:"IFCCHIMNEYTYPE",167062518:"IFCBSPLINESURFACEWITHKNOTS",2887950389:"IFCBSPLINESURFACE",2603310189:"IFCADVANCEDBREPWITHVOIDS",1635779807:"IFCADVANCEDBREP",2916149573:"IFCTRIANGULATEDFACESET",1935646853:"IFCTOROIDALSURFACE",2387106220:"IFCTESSELLATEDFACESET",3206491090:"IFCTASKTYPE",699246055:"IFCSURFACECURVE",4095615324:"IFCSUBCONTRACTRESOURCETYPE",603775116:"IFCSTRUCTURALSURFACEREACTION",4015995234:"IFCSPHERICALSURFACE",2481509218:"IFCSPATIALZONETYPE",463610769:"IFCSPATIALZONE",710998568:"IFCSPATIALELEMENTTYPE",1412071761:"IFCSPATIALELEMENT",3663146110:"IFCSIMPLEPROPERTYTEMPLATE",3243963512:"IFCREVOLVEDAREASOLIDTAPERED",816062949:"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",1521410863:"IFCRELSPACEBOUNDARY2NDLEVEL",3523091289:"IFCRELSPACEBOUNDARY1STLEVEL",427948657:"IFCRELINTERFERESELEMENTS",307848117:"IFCRELDEFINESBYTEMPLATE",1462361463:"IFCRELDEFINESBYOBJECT",2565941209:"IFCRELDECLARES",1027710054:"IFCRELASSIGNSTOGROUPBYFACTOR",3521284610:"IFCPROPERTYTEMPLATE",492091185:"IFCPROPERTYSETTEMPLATE",653396225:"IFCPROJECTLIBRARY",569719735:"IFCPROCEDURETYPE",3967405729:"IFCPREDEFINEDPROPERTYSET",1682466193:"IFCPCURVE",428585644:"IFCLABORRESOURCETYPE",2294589976:"IFCINDEXEDPOLYGONALFACEWITHVOIDS",178912537:"IFCINDEXEDPOLYGONALFACE",4095422895:"IFCGEOGRAPHICELEMENTTYPE",2652556860:"IFCFIXEDREFERENCESWEPTAREASOLID",2804161546:"IFCEXTRUDEDAREASOLIDTAPERED",4024345920:"IFCEVENTTYPE",2629017746:"IFCCURVEBOUNDEDSURFACE",1815067380:"IFCCREWRESOURCETYPE",3419103109:"IFCCONTEXT",2574617495:"IFCCONSTRUCTIONRESOURCETYPE",2059837836:"IFCCARTESIANPOINTLIST3D",1675464909:"IFCCARTESIANPOINTLIST2D",574549367:"IFCCARTESIANPOINTLIST",3406155212:"IFCADVANCEDFACE",3698973494:"IFCTYPERESOURCE",3736923433:"IFCTYPEPROCESS",901063453:"IFCTESSELLATEDITEM",1096409881:"IFCSWEPTDISKSOLIDPOLYGONAL",1042787934:"IFCRESOURCETIME",1608871552:"IFCRESOURCECONSTRAINTRELATIONSHIP",2943643501:"IFCRESOURCEAPPROVALRELATIONSHIP",2090586900:"IFCQUANTITYSET",1482703590:"IFCPROPERTYTEMPLATEDEFINITION",3778827333:"IFCPREDEFINEDPROPERTIES",2998442950:"IFCMIRROREDPROFILEDEF",853536259:"IFCMATERIALRELATIONSHIP",3404854881:"IFCMATERIALPROFILESETUSAGETAPERING",3079605661:"IFCMATERIALPROFILESETUSAGE",2852063980:"IFCMATERIALCONSTITUENTSET",3708119e3:"IFCMATERIALCONSTITUENT",1585845231:"IFCLAGTIME",2133299955:"IFCINDEXEDTRIANGLETEXTUREMAP",1437953363:"IFCINDEXEDTEXTUREMAP",3570813810:"IFCINDEXEDCOLOURMAP",1437805879:"IFCEXTERNALREFERENCERELATIONSHIP",297599258:"IFCEXTENDEDPROPERTIES",211053100:"IFCEVENTTIME",2713554722:"IFCCONVERSIONBASEDUNITWITHOFFSET",3285139300:"IFCCOLOURRGBLIST",1236880293:"IFCWORKTIME",1199560280:"IFCTIMEPERIOD",3611470254:"IFCTEXTUREVERTEXLIST",2771591690:"IFCTASKTIMERECURRING",1549132990:"IFCTASKTIME",2043862942:"IFCTABLECOLUMN",2934153892:"IFCSURFACEREINFORCEMENTAREA",609421318:"IFCSTRUCTURALLOADORRESULT",3478079324:"IFCSTRUCTURALLOADCONFIGURATION",1054537805:"IFCSCHEDULINGTIME",2439245199:"IFCRESOURCELEVELRELATIONSHIP",2433181523:"IFCREFERENCE",3915482550:"IFCRECURRENCEPATTERN",986844984:"IFCPROPERTYABSTRACTION",3843373140:"IFCPROJECTEDCRS",677532197:"IFCPRESENTATIONITEM",1507914824:"IFCMATERIALUSAGEDEFINITION",552965576:"IFCMATERIALPROFILEWITHOFFSETS",164193824:"IFCMATERIALPROFILESET",2235152071:"IFCMATERIALPROFILE",1847252529:"IFCMATERIALLAYERWITHOFFSETS",760658860:"IFCMATERIALDEFINITION",3057273783:"IFCMAPCONVERSION",4294318154:"IFCEXTERNALINFORMATION",1466758467:"IFCCOORDINATEREFERENCESYSTEM",1785450214:"IFCCOORDINATEOPERATION",775493141:"IFCCONNECTIONVOLUMEGEOMETRY",979691226:"IFCREINFORCINGBAR",3700593921:"IFCELECTRICDISTRIBUTIONPOINT",1062813311:"IFCDISTRIBUTIONCONTROLELEMENT",1052013943:"IFCDISTRIBUTIONCHAMBERELEMENT",578613899:"IFCCONTROLLERTYPE",2454782716:"IFCCHAMFEREDGEFEATURE",753842376:"IFCBEAM",3001207471:"IFCALARMTYPE",2874132201:"IFCACTUATORTYPE",3304561284:"IFCWINDOW",3512223829:"IFCWALLSTANDARDCASE",2391406946:"IFCWALL",3313531582:"IFCVIBRATIONISOLATORTYPE",2347447852:"IFCTENDONANCHOR",3824725483:"IFCTENDON",2515109513:"IFCSTRUCTURALANALYSISMODEL",4252922144:"IFCSTAIRFLIGHT",331165859:"IFCSTAIR",1529196076:"IFCSLAB",1783015770:"IFCSENSORTYPE",1376911519:"IFCROUNDEDEDGEFEATURE",2016517767:"IFCROOF",2320036040:"IFCREINFORCINGMESH",3027567501:"IFCREINFORCINGELEMENT",3055160366:"IFCRATIONALBEZIERCURVE",3283111854:"IFCRAMPFLIGHT",3024970846:"IFCRAMP",2262370178:"IFCRAILING",3171933400:"IFCPLATE",1687234759:"IFCPILE",1073191201:"IFCMEMBER",900683007:"IFCFOOTING",3508470533:"IFCFLOWTREATMENTDEVICE",2223149337:"IFCFLOWTERMINAL",707683696:"IFCFLOWSTORAGEDEVICE",987401354:"IFCFLOWSEGMENT",3132237377:"IFCFLOWMOVINGDEVICE",4037862832:"IFCFLOWINSTRUMENTTYPE",4278956645:"IFCFLOWFITTING",2058353004:"IFCFLOWCONTROLLER",4222183408:"IFCFIRESUPPRESSIONTERMINALTYPE",1810631287:"IFCFILTERTYPE",346874300:"IFCFANTYPE",1658829314:"IFCENERGYCONVERSIONDEVICE",857184966:"IFCELECTRICALELEMENT",1634875225:"IFCELECTRICALCIRCUIT",712377611:"IFCELECTRICTIMECONTROLTYPE",1217240411:"IFCELECTRICMOTORTYPE",1365060375:"IFCELECTRICHEATERTYPE",1534661035:"IFCELECTRICGENERATORTYPE",3277789161:"IFCELECTRICFLOWSTORAGEDEVICETYPE",663422040:"IFCELECTRICAPPLIANCETYPE",855621170:"IFCEDGEFEATURE",2030761528:"IFCDUCTSILENCERTYPE",3760055223:"IFCDUCTSEGMENTTYPE",869906466:"IFCDUCTFITTINGTYPE",395920057:"IFCDOOR",3041715199:"IFCDISTRIBUTIONPORT",3040386961:"IFCDISTRIBUTIONFLOWELEMENT",1945004755:"IFCDISTRIBUTIONELEMENT",2063403501:"IFCDISTRIBUTIONCONTROLELEMENTTYPE",1599208980:"IFCDISTRIBUTIONCHAMBERELEMENTTYPE",2635815018:"IFCDISCRETEACCESSORYTYPE",1335981549:"IFCDISCRETEACCESSORY",4147604152:"IFCDIAMETERDIMENSION",3961806047:"IFCDAMPERTYPE",3495092785:"IFCCURTAINWALL",1973544240:"IFCCOVERING",2954562838:"IFCCOOLINGTOWERTYPE",335055490:"IFCCOOLEDBEAMTYPE",488727124:"IFCCONSTRUCTIONPRODUCTRESOURCE",1060000209:"IFCCONSTRUCTIONMATERIALRESOURCE",3898045240:"IFCCONSTRUCTIONEQUIPMENTRESOURCE",1163958913:"IFCCONDITIONCRITERION",2188551683:"IFCCONDITION",2816379211:"IFCCONDENSERTYPE",3850581409:"IFCCOMPRESSORTYPE",843113511:"IFCCOLUMN",2301859152:"IFCCOILTYPE",2611217952:"IFCCIRCLE",2951183804:"IFCCHILLERTYPE",1285652485:"IFCCABLESEGMENTTYPE",3293546465:"IFCCABLECARRIERSEGMENTTYPE",395041908:"IFCCABLECARRIERFITTINGTYPE",1909888760:"IFCBUILDINGELEMENTPROXYTYPE",1095909175:"IFCBUILDINGELEMENTPROXY",2979338954:"IFCBUILDINGELEMENTPART",52481810:"IFCBUILDINGELEMENTCOMPONENT",3299480353:"IFCBUILDINGELEMENT",231477066:"IFCBOILERTYPE",1916977116:"IFCBEZIERCURVE",819618141:"IFCBEAMTYPE",1967976161:"IFCBSPLINECURVE",3460190687:"IFCASSET",2470393545:"IFCANGULARDIMENSION",1871374353:"IFCAIRTOAIRHEATRECOVERYTYPE",3352864051:"IFCAIRTERMINALTYPE",1411407467:"IFCAIRTERMINALBOXTYPE",3821786052:"IFCACTIONREQUEST",1213861670:"IFC2DCOMPOSITECURVE",1033361043:"IFCZONE",3342526732:"IFCWORKSCHEDULE",4218914973:"IFCWORKPLAN",1028945134:"IFCWORKCONTROL",1133259667:"IFCWASTETERMINALTYPE",1898987631:"IFCWALLTYPE",2769231204:"IFCVIRTUALELEMENT",728799441:"IFCVALVETYPE",1911125066:"IFCUNITARYEQUIPMENTTYPE",1600972822:"IFCTUBEBUNDLETYPE",3593883385:"IFCTRIMMEDCURVE",1620046519:"IFCTRANSPORTELEMENT",1692211062:"IFCTRANSFORMERTYPE",1637806684:"IFCTIMESERIESSCHEDULE",5716631:"IFCTANKTYPE",2254336722:"IFCSYSTEM",2315554128:"IFCSWITCHINGDEVICETYPE",148013059:"IFCSUBCONTRACTRESOURCE",1975003073:"IFCSTRUCTURALSURFACECONNECTION",2986769608:"IFCSTRUCTURALRESULTGROUP",1235345126:"IFCSTRUCTURALPOINTREACTION",734778138:"IFCSTRUCTURALPOINTCONNECTION",2082059205:"IFCSTRUCTURALPOINTACTION",3987759626:"IFCSTRUCTURALPLANARACTIONVARYING",1621171031:"IFCSTRUCTURALPLANARACTION",1252848954:"IFCSTRUCTURALLOADGROUP",1721250024:"IFCSTRUCTURALLINEARACTIONVARYING",1807405624:"IFCSTRUCTURALLINEARACTION",2445595289:"IFCSTRUCTURALCURVEMEMBERVARYING",214636428:"IFCSTRUCTURALCURVEMEMBER",4243806635:"IFCSTRUCTURALCURVECONNECTION",1179482911:"IFCSTRUCTURALCONNECTION",682877961:"IFCSTRUCTURALACTION",1039846685:"IFCSTAIRFLIGHTTYPE",3112655638:"IFCSTACKTERMINALTYPE",3812236995:"IFCSPACETYPE",652456506:"IFCSPACEPROGRAM",1305183839:"IFCSPACEHEATERTYPE",3856911033:"IFCSPACE",2533589738:"IFCSLABTYPE",4097777520:"IFCSITE",4105383287:"IFCSERVICELIFE",3517283431:"IFCSCHEDULETIMECONTROL",1768891740:"IFCSANITARYTERMINALTYPE",2863920197:"IFCRELASSIGNSTASKS",160246688:"IFCRELAGGREGATES",2324767716:"IFCRAMPFLIGHTTYPE",2893384427:"IFCRAILINGTYPE",3248260540:"IFCRADIUSDIMENSION",2250791053:"IFCPUMPTYPE",1842657554:"IFCPROTECTIVEDEVICETYPE",3651124850:"IFCPROJECTIONELEMENT",3642467123:"IFCPROJECTORDERRECORD",2904328755:"IFCPROJECTORDER",2744685151:"IFCPROCEDURE",3740093272:"IFCPORT",3724593414:"IFCPOLYLINE",4017108033:"IFCPLATETYPE",4231323485:"IFCPIPESEGMENTTYPE",804291784:"IFCPIPEFITTINGTYPE",3327091369:"IFCPERMIT",2382730787:"IFCPERFORMANCEHISTORY",2837617999:"IFCOUTLETTYPE",3425660407:"IFCORDERACTION",3588315303:"IFCOPENINGELEMENT",4143007308:"IFCOCCUPANT",1916936684:"IFCMOVE",977012517:"IFCMOTORCONNECTIONTYPE",3181161470:"IFCMEMBERTYPE",2108223431:"IFCMECHANICALFASTENERTYPE",377706215:"IFCMECHANICALFASTENER",2506943328:"IFCLINEARDIMENSION",1161773419:"IFCLIGHTFIXTURETYPE",1051575348:"IFCLAMPTYPE",3827777499:"IFCLABORRESOURCE",4288270099:"IFCJUNCTIONBOXTYPE",2391368822:"IFCINVENTORY",1806887404:"IFCHUMIDIFIERTYPE",1251058090:"IFCHEATEXCHANGERTYPE",2706460486:"IFCGROUP",3009204131:"IFCGRID",200128114:"IFCGASTERMINALTYPE",814719939:"IFCFURNITURESTANDARD",263784265:"IFCFURNISHINGELEMENT",3009222698:"IFCFLOWTREATMENTDEVICETYPE",2297155007:"IFCFLOWTERMINALTYPE",1339347760:"IFCFLOWSTORAGEDEVICETYPE",1834744321:"IFCFLOWSEGMENTTYPE",1482959167:"IFCFLOWMOVINGDEVICETYPE",3815607619:"IFCFLOWMETERTYPE",3198132628:"IFCFLOWFITTINGTYPE",3907093117:"IFCFLOWCONTROLLERTYPE",1287392070:"IFCFEATUREELEMENTSUBTRACTION",2143335405:"IFCFEATUREELEMENTADDITION",2827207264:"IFCFEATUREELEMENT",2489546625:"IFCFASTENERTYPE",647756555:"IFCFASTENER",3737207727:"IFCFACETEDBREPWITHVOIDS",807026263:"IFCFACETEDBREP",3390157468:"IFCEVAPORATORTYPE",3174744832:"IFCEVAPORATIVECOOLERTYPE",3272907226:"IFCEQUIPMENTSTANDARD",1962604670:"IFCEQUIPMENTELEMENT",2107101300:"IFCENERGYCONVERSIONDEVICETYPE",1704287377:"IFCELLIPSE",2590856083:"IFCELEMENTCOMPONENTTYPE",1623761950:"IFCELEMENTCOMPONENT",4123344466:"IFCELEMENTASSEMBLY",1758889154:"IFCELEMENT",360485395:"IFCELECTRICALBASEPROPERTIES",3849074793:"IFCDISTRIBUTIONFLOWELEMENTTYPE",3256556792:"IFCDISTRIBUTIONELEMENTTYPE",681481545:"IFCDIMENSIONCURVEDIRECTEDCALLOUT",1457835157:"IFCCURTAINWALLTYPE",3295246426:"IFCCREWRESOURCE",1916426348:"IFCCOVERINGTYPE",1419761937:"IFCCOSTSCHEDULE",3895139033:"IFCCOSTITEM",3293443760:"IFCCONTROL",2559216714:"IFCCONSTRUCTIONRESOURCE",2510884976:"IFCCONIC",3732776249:"IFCCOMPOSITECURVE",300633059:"IFCCOLUMNTYPE",2937912522:"IFCCIRCLEHOLLOWPROFILEDEF",3124254112:"IFCBUILDINGSTOREY",1950629157:"IFCBUILDINGELEMENTTYPE",4031249490:"IFCBUILDING",1260505505:"IFCBOUNDEDCURVE",3649129432:"IFCBOOLEANCLIPPINGRESULT",1334484129:"IFCBLOCK",3207858831:"IFCASYMMETRICISHAPEPROFILEDEF",1674181508:"IFCANNOTATION",2296667514:"IFCACTOR",2097647324:"IFCTRANSPORTELEMENTTYPE",3473067441:"IFCTASK",1580310250:"IFCSYSTEMFURNITUREELEMENTTYPE",4124788165:"IFCSURFACEOFREVOLUTION",2809605785:"IFCSURFACEOFLINEAREXTRUSION",2028607225:"IFCSURFACECURVESWEPTAREASOLID",4070609034:"IFCSTRUCTUREDDIMENSIONCALLOUT",2218152070:"IFCSTRUCTURALSURFACEMEMBERVARYING",3979015343:"IFCSTRUCTURALSURFACEMEMBER",3689010777:"IFCSTRUCTURALREACTION",530289379:"IFCSTRUCTURALMEMBER",3136571912:"IFCSTRUCTURALITEM",3544373492:"IFCSTRUCTURALACTIVITY",451544542:"IFCSPHERE",3893378262:"IFCSPATIALSTRUCTUREELEMENTTYPE",2706606064:"IFCSPATIALSTRUCTUREELEMENT",3626867408:"IFCRIGHTCIRCULARCYLINDER",4158566097:"IFCRIGHTCIRCULARCONE",1856042241:"IFCREVOLVEDAREASOLID",2914609552:"IFCRESOURCE",1401173127:"IFCRELVOIDSELEMENT",3451746338:"IFCRELSPACEBOUNDARY",366585022:"IFCRELSERVICESBUILDINGS",4122056220:"IFCRELSEQUENCE",1058617721:"IFCRELSCHEDULESCOSTITEMS",1245217292:"IFCRELREFERENCEDINSPATIALSTRUCTURE",750771296:"IFCRELPROJECTSELEMENT",202636808:"IFCRELOVERRIDESPROPERTIES",2051452291:"IFCRELOCCUPIESSPACES",3268803585:"IFCRELNESTS",4189434867:"IFCRELINTERACTIONREQUIREMENTS",279856033:"IFCRELFLOWCONTROLELEMENTS",3940055652:"IFCRELFILLSELEMENT",781010003:"IFCRELDEFINESBYTYPE",4186316022:"IFCRELDEFINESBYPROPERTIES",693640335:"IFCRELDEFINES",2551354335:"IFCRELDECOMPOSES",2802773753:"IFCRELCOVERSSPACES",886880790:"IFCRELCOVERSBLDGELEMENTS",3242617779:"IFCRELCONTAINEDINSPATIALSTRUCTURE",3678494232:"IFCRELCONNECTSWITHREALIZINGELEMENTS",504942748:"IFCRELCONNECTSWITHECCENTRICITY",1638771189:"IFCRELCONNECTSSTRUCTURALMEMBER",3912681535:"IFCRELCONNECTSSTRUCTURALELEMENT",2127690289:"IFCRELCONNECTSSTRUCTURALACTIVITY",3190031847:"IFCRELCONNECTSPORTS",4201705270:"IFCRELCONNECTSPORTTOELEMENT",3945020480:"IFCRELCONNECTSPATHELEMENTS",1204542856:"IFCRELCONNECTSELEMENTS",826625072:"IFCRELCONNECTS",2851387026:"IFCRELASSOCIATESPROFILEPROPERTIES",2655215786:"IFCRELASSOCIATESMATERIAL",3840914261:"IFCRELASSOCIATESLIBRARY",982818633:"IFCRELASSOCIATESDOCUMENT",2728634034:"IFCRELASSOCIATESCONSTRAINT",919958153:"IFCRELASSOCIATESCLASSIFICATION",4095574036:"IFCRELASSOCIATESAPPROVAL",1327628568:"IFCRELASSOCIATESAPPLIEDVALUE",1865459582:"IFCRELASSOCIATES",205026976:"IFCRELASSIGNSTORESOURCE",3372526763:"IFCRELASSIGNSTOPROJECTORDER",2857406711:"IFCRELASSIGNSTOPRODUCT",4278684876:"IFCRELASSIGNSTOPROCESS",1307041759:"IFCRELASSIGNSTOGROUP",2495723537:"IFCRELASSIGNSTOCONTROL",1683148259:"IFCRELASSIGNSTOACTOR",3939117080:"IFCRELASSIGNS",3454111270:"IFCRECTANGULARTRIMMEDSURFACE",2798486643:"IFCRECTANGULARPYRAMID",2770003689:"IFCRECTANGLEHOLLOWPROFILEDEF",3219374653:"IFCPROXY",1451395588:"IFCPROPERTYSET",4194566429:"IFCPROJECTIONCURVE",103090709:"IFCPROJECT",4208778838:"IFCPRODUCT",2945172077:"IFCPROCESS",220341763:"IFCPLANE",603570806:"IFCPLANARBOX",3566463478:"IFCPERMEABLECOVERINGPROPERTIES",3505215534:"IFCOFFSETCURVE3D",3388369263:"IFCOFFSETCURVE2D",3888040117:"IFCOBJECT",1425443689:"IFCMANIFOLDSOLIDBREP",1281925730:"IFCLINE",572779678:"IFCLSHAPEPROFILEDEF",1484403080:"IFCISHAPEPROFILEDEF",987898635:"IFCGEOMETRICCURVESET",1268542332:"IFCFURNITURETYPE",4238390223:"IFCFURNISHINGELEMENTTYPE",3455213021:"IFCFLUIDFLOWPROPERTIES",315944413:"IFCFILLAREASTYLETILES",4203026998:"IFCFILLAREASTYLETILESYMBOLWITHSTYLE",374418227:"IFCFILLAREASTYLEHATCHING",2047409740:"IFCFACEBASEDSURFACEMODEL",477187591:"IFCEXTRUDEDAREASOLID",80994333:"IFCENERGYPROPERTIES",2835456948:"IFCELLIPSEPROFILEDEF",2777663545:"IFCELEMENTARYSURFACE",339256511:"IFCELEMENTTYPE",1883228015:"IFCELEMENTQUANTITY",1472233963:"IFCEDGELOOP",4006246654:"IFCDRAUGHTINGPREDEFINEDCURVEFONT",445594917:"IFCDRAUGHTINGPREDEFINEDCOLOUR",3073041342:"IFCDRAUGHTINGCALLOUT",526551008:"IFCDOORSTYLE",1714330368:"IFCDOORPANELPROPERTIES",2963535650:"IFCDOORLININGPROPERTIES",32440307:"IFCDIRECTION",4054601972:"IFCDIMENSIONCURVETERMINATOR",606661476:"IFCDIMENSIONCURVE",693772133:"IFCDEFINEDSYMBOL",2827736869:"IFCCURVEBOUNDEDPLANE",2601014836:"IFCCURVE",2147822146:"IFCCSGSOLID",2506170314:"IFCCSGPRIMITIVE3D",194851669:"IFCCRANERAILFSHAPEPROFILEDEF",4133800736:"IFCCRANERAILASHAPEPROFILEDEF",2485617015:"IFCCOMPOSITECURVESEGMENT",2205249479:"IFCCLOSEDSHELL",1383045692:"IFCCIRCLEPROFILEDEF",1416205885:"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",3331915920:"IFCCARTESIANTRANSFORMATIONOPERATOR3D",3486308946:"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",3749851601:"IFCCARTESIANTRANSFORMATIONOPERATOR2D",59481748:"IFCCARTESIANTRANSFORMATIONOPERATOR",1123145078:"IFCCARTESIANPOINT",2898889636:"IFCCSHAPEPROFILEDEF",2713105998:"IFCBOXEDHALFSPACE",2581212453:"IFCBOUNDINGBOX",4182860854:"IFCBOUNDEDSURFACE",2736907675:"IFCBOOLEANRESULT",2740243338:"IFCAXIS2PLACEMENT3D",3125803723:"IFCAXIS2PLACEMENT2D",4261334040:"IFCAXIS1PLACEMENT",1302238472:"IFCANNOTATIONSURFACE",2265737646:"IFCANNOTATIONFILLAREAOCCURRENCE",669184980:"IFCANNOTATIONFILLAREA",3288037868:"IFCANNOTATIONCURVEOCCURRENCE",2543172580:"IFCZSHAPEPROFILEDEF",1299126871:"IFCWINDOWSTYLE",512836454:"IFCWINDOWPANELPROPERTIES",336235671:"IFCWINDOWLININGPROPERTIES",2759199220:"IFCVERTEXLOOP",1417489154:"IFCVECTOR",427810014:"IFCUSHAPEPROFILEDEF",2347495698:"IFCTYPEPRODUCT",1628702193:"IFCTYPEOBJECT",1345879162:"IFCTWODIRECTIONREPEATFACTOR",2715220739:"IFCTRAPEZIUMPROFILEDEF",3124975700:"IFCTEXTLITERALWITHEXTENT",4282788508:"IFCTEXTLITERAL",3028897424:"IFCTERMINATORSYMBOL",3071757647:"IFCTSHAPEPROFILEDEF",230924584:"IFCSWEPTSURFACE",1260650574:"IFCSWEPTDISKSOLID",2247615214:"IFCSWEPTAREASOLID",1878645084:"IFCSURFACESTYLERENDERING",2513912981:"IFCSURFACE",2233826070:"IFCSUBEDGE",3653947884:"IFCSTRUCTURALSTEELPROFILEPROPERTIES",3843319758:"IFCSTRUCTURALPROFILEPROPERTIES",1190533807:"IFCSTRUCTURALLOADSINGLEFORCEWARPING",1597423693:"IFCSTRUCTURALLOADSINGLEFORCE",1973038258:"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",2473145415:"IFCSTRUCTURALLOADSINGLEDISPLACEMENT",2668620305:"IFCSTRUCTURALLOADPLANARFORCE",1595516126:"IFCSTRUCTURALLOADLINEARFORCE",390701378:"IFCSPACETHERMALLOADPROPERTIES",1202362311:"IFCSOUNDVALUE",2485662743:"IFCSOUNDPROPERTIES",723233188:"IFCSOLIDMODEL",2609359061:"IFCSLIPPAGECONNECTIONCONDITION",4124623270:"IFCSHELLBASEDSURFACEMODEL",2411513650:"IFCSERVICELIFEFACTOR",1509187699:"IFCSECTIONEDSPINE",2778083089:"IFCROUNDEDRECTANGLEPROFILEDEF",478536968:"IFCRELATIONSHIP",3765753017:"IFCREINFORCEMENTDEFINITIONPROPERTIES",3413951693:"IFCREGULARTIMESERIES",3615266464:"IFCRECTANGLEPROFILEDEF",110355661:"IFCPROPERTYTABLEVALUE",3650150729:"IFCPROPERTYSINGLEVALUE",3357820518:"IFCPROPERTYSETDEFINITION",941946838:"IFCPROPERTYREFERENCEVALUE",2752243245:"IFCPROPERTYLISTVALUE",4166981789:"IFCPROPERTYENUMERATEDVALUE",1680319473:"IFCPROPERTYDEFINITION",871118103:"IFCPROPERTYBOUNDEDVALUE",673634403:"IFCPRODUCTDEFINITIONSHAPE",179317114:"IFCPREDEFINEDPOINTMARKERSYMBOL",433424934:"IFCPREDEFINEDDIMENSIONSYMBOL",2559016684:"IFCPREDEFINEDCURVEFONT",759155922:"IFCPREDEFINEDCOLOUR",2775532180:"IFCPOLYGONALBOUNDEDHALFSPACE",2924175390:"IFCPOLYLOOP",1423911732:"IFCPOINTONSURFACE",4022376103:"IFCPOINTONCURVE",2067069095:"IFCPOINT",1663979128:"IFCPLANAREXTENT",2004835150:"IFCPLACEMENT",597895409:"IFCPIXELTEXTURE",3021840470:"IFCPHYSICALCOMPLEXQUANTITY",2519244187:"IFCPATH",2529465313:"IFCPARAMETERIZEDPROFILEDEF",1029017970:"IFCORIENTEDEDGE",2665983363:"IFCOPENSHELL",2833995503:"IFCONEDIRECTIONREPEATFACTOR",219451334:"IFCOBJECTDEFINITION",1430189142:"IFCMECHANICALCONCRETEMATERIALPROPERTIES",2022407955:"IFCMATERIALDEFINITIONREPRESENTATION",2347385850:"IFCMAPPEDITEM",1008929658:"IFCLOOP",2624227202:"IFCLOCALPLACEMENT",3422422726:"IFCLIGHTSOURCESPOT",1520743889:"IFCLIGHTSOURCEPOSITIONAL",4266656042:"IFCLIGHTSOURCEGONIOMETRIC",2604431987:"IFCLIGHTSOURCEDIRECTIONAL",125510826:"IFCLIGHTSOURCEAMBIENT",1402838566:"IFCLIGHTSOURCE",3741457305:"IFCIRREGULARTIMESERIES",3905492369:"IFCIMAGETEXTURE",2445078500:"IFCHYGROSCOPICMATERIALPROPERTIES",812098782:"IFCHALFSPACESOLID",178086475:"IFCGRIDPLACEMENT",3590301190:"IFCGEOMETRICSET",4142052618:"IFCGEOMETRICREPRESENTATIONSUBCONTEXT",2453401579:"IFCGEOMETRICREPRESENTATIONITEM",3448662350:"IFCGEOMETRICREPRESENTATIONCONTEXT",1446786286:"IFCGENERALPROFILEPROPERTIES",803998398:"IFCGENERALMATERIALPROPERTIES",3857492461:"IFCFUELPROPERTIES",738692330:"IFCFILLAREASTYLE",4219587988:"IFCFAILURECONNECTIONCONDITION",3008276851:"IFCFACESURFACE",803316827:"IFCFACEOUTERBOUND",1809719519:"IFCFACEBOUND",2556980723:"IFCFACE",1860660968:"IFCEXTENDEDMATERIALPROPERTIES",476780140:"IFCEDGECURVE",3900360178:"IFCEDGE",4170525392:"IFCDRAUGHTINGPREDEFINEDTEXTFONT",3732053477:"IFCDOCUMENTREFERENCE",1694125774:"IFCDIMENSIONPAIR",2273265877:"IFCDIMENSIONCALLOUTRELATIONSHIP",3632507154:"IFCDERIVEDPROFILEDEF",3800577675:"IFCCURVESTYLE",2889183280:"IFCCONVERSIONBASEDUNIT",3050246964:"IFCCONTEXTDEPENDENTUNIT",45288368:"IFCCONNECTIONPOINTECCENTRICITY",1981873012:"IFCCONNECTIONCURVEGEOMETRY",370225590:"IFCCONNECTEDFACESET",1485152156:"IFCCOMPOSITEPROFILEDEF",2542286263:"IFCCOMPLEXPROPERTY",776857604:"IFCCOLOURRGB",647927063:"IFCCLASSIFICATIONREFERENCE",3150382593:"IFCCENTERLINEPROFILEDEF",616511568:"IFCBLOBTEXTURE",2705031697:"IFCARBITRARYPROFILEDEFWITHVOIDS",1310608509:"IFCARBITRARYOPENPROFILEDEF",3798115385:"IFCARBITRARYCLOSEDPROFILEDEF",2297822566:"IFCANNOTATIONTEXTOCCURRENCE",3612888222:"IFCANNOTATIONSYMBOLOCCURRENCE",962685235:"IFCANNOTATIONSURFACEOCCURRENCE",2442683028:"IFCANNOTATIONOCCURRENCE",1065908215:"IFCWATERPROPERTIES",891718957:"IFCVIRTUALGRIDINTERSECTION",1907098498:"IFCVERTEXPOINT",3304826586:"IFCVERTEXBASEDTEXTUREMAP",2799835756:"IFCVERTEX",180925521:"IFCUNITASSIGNMENT",1735638870:"IFCTOPOLOGYREPRESENTATION",1377556343:"IFCTOPOLOGICALREPRESENTATIONITEM",581633288:"IFCTIMESERIESVALUE",1718945513:"IFCTIMESERIESREFERENCERELATIONSHIP",3101149627:"IFCTIMESERIES",3317419933:"IFCTHERMALMATERIALPROPERTIES",1210645708:"IFCTEXTUREVERTEX",2552916305:"IFCTEXTUREMAP",1742049831:"IFCTEXTURECOORDINATEGENERATOR",280115917:"IFCTEXTURECOORDINATE",1484833681:"IFCTEXTSTYLEWITHBOXCHARACTERISTICS",1640371178:"IFCTEXTSTYLETEXTMODEL",2636378356:"IFCTEXTSTYLEFORDEFINEDFONT",1983826977:"IFCTEXTSTYLEFONTMODEL",1447204868:"IFCTEXTSTYLE",912023232:"IFCTELECOMADDRESS",531007025:"IFCTABLEROW",985171141:"IFCTABLE",1290481447:"IFCSYMBOLSTYLE",626085974:"IFCSURFACETEXTURE",1351298697:"IFCSURFACESTYLEWITHTEXTURES",846575682:"IFCSURFACESTYLESHADING",1607154358:"IFCSURFACESTYLEREFRACTION",3303107099:"IFCSURFACESTYLELIGHTING",1300840506:"IFCSURFACESTYLE",3049322572:"IFCSTYLEDREPRESENTATION",3958052878:"IFCSTYLEDITEM",2830218821:"IFCSTYLEMODEL",3408363356:"IFCSTRUCTURALLOADTEMPERATURE",2525727697:"IFCSTRUCTURALLOADSTATIC",2162789131:"IFCSTRUCTURALLOAD",2273995522:"IFCSTRUCTURALCONNECTIONCONDITION",3692461612:"IFCSIMPLEPROPERTY",4240577450:"IFCSHAPEREPRESENTATION",3982875396:"IFCSHAPEMODEL",867548509:"IFCSHAPEASPECT",4165799628:"IFCSECTIONREINFORCEMENTPROPERTIES",2042790032:"IFCSECTIONPROPERTIES",448429030:"IFCSIUNIT",2341007311:"IFCROOT",3679540991:"IFCRIBPLATEPROFILEPROPERTIES",1660063152:"IFCREPRESENTATIONMAP",3008791417:"IFCREPRESENTATIONITEM",3377609919:"IFCREPRESENTATIONCONTEXT",1076942058:"IFCREPRESENTATION",1222501353:"IFCRELAXATION",1580146022:"IFCREINFORCEMENTBARPROPERTIES",2692823254:"IFCREFERENCESVALUEDOCUMENT",825690147:"IFCQUANTITYWEIGHT",2405470396:"IFCQUANTITYVOLUME",3252649465:"IFCQUANTITYTIME",931644368:"IFCQUANTITYLENGTH",2093928680:"IFCQUANTITYCOUNT",2044713172:"IFCQUANTITYAREA",3710013099:"IFCPROPERTYENUMERATION",148025276:"IFCPROPERTYDEPENDENCYRELATIONSHIP",3896028662:"IFCPROPERTYCONSTRAINTRELATIONSHIP",2598011224:"IFCPROPERTY",2802850158:"IFCPROFILEPROPERTIES",3958567839:"IFCPROFILEDEF",2267347899:"IFCPRODUCTSOFCOMBUSTIONPROPERTIES",2095639259:"IFCPRODUCTREPRESENTATION",2417041796:"IFCPRESENTATIONSTYLEASSIGNMENT",3119450353:"IFCPRESENTATIONSTYLE",1304840413:"IFCPRESENTATIONLAYERWITHSTYLE",2022622350:"IFCPRESENTATIONLAYERASSIGNMENT",1775413392:"IFCPREDEFINEDTEXTFONT",3213052703:"IFCPREDEFINEDTERMINATORSYMBOL",990879717:"IFCPREDEFINEDSYMBOL",3727388367:"IFCPREDEFINEDITEM",3355820592:"IFCPOSTALADDRESS",2226359599:"IFCPHYSICALSIMPLEQUANTITY",2483315170:"IFCPHYSICALQUANTITY",101040310:"IFCPERSONANDORGANIZATION",2077209135:"IFCPERSON",1207048766:"IFCOWNERHISTORY",1411181986:"IFCORGANIZATIONRELATIONSHIP",4251960020:"IFCORGANIZATION",1227763645:"IFCOPTICALMATERIALPROPERTIES",2251480897:"IFCOBJECTIVE",3701648758:"IFCOBJECTPLACEMENT",1918398963:"IFCNAMEDUNIT",2706619895:"IFCMONETARYUNIT",3368373690:"IFCMETRIC",677618848:"IFCMECHANICALSTEELMATERIALPROPERTIES",4256014907:"IFCMECHANICALMATERIALPROPERTIES",2597039031:"IFCMEASUREWITHUNIT",3265635763:"IFCMATERIALPROPERTIES",2199411900:"IFCMATERIALLIST",1303795690:"IFCMATERIALLAYERSETUSAGE",3303938423:"IFCMATERIALLAYERSET",248100487:"IFCMATERIALLAYER",1847130766:"IFCMATERIALCLASSIFICATIONRELATIONSHIP",1838606355:"IFCMATERIAL",30780891:"IFCLOCALTIME",1566485204:"IFCLIGHTINTENSITYDISTRIBUTION",4162380809:"IFCLIGHTDISTRIBUTIONDATA",3452421091:"IFCLIBRARYREFERENCE",2655187982:"IFCLIBRARYINFORMATION",3020489413:"IFCIRREGULARTIMESERIESVALUE",852622518:"IFCGRIDAXIS",3548104201:"IFCEXTERNALLYDEFINEDTEXTFONT",3207319532:"IFCEXTERNALLYDEFINEDSYMBOL",1040185647:"IFCEXTERNALLYDEFINEDSURFACESTYLE",2242383968:"IFCEXTERNALLYDEFINEDHATCHSTYLE",3200245327:"IFCEXTERNALREFERENCE",1648886627:"IFCENVIRONMENTALIMPACTVALUE",3796139169:"IFCDRAUGHTINGCALLOUTRELATIONSHIP",770865208:"IFCDOCUMENTINFORMATIONRELATIONSHIP",1154170062:"IFCDOCUMENTINFORMATION",1376555844:"IFCDOCUMENTELECTRONICFORMAT",2949456006:"IFCDIMENSIONALEXPONENTS",1045800335:"IFCDERIVEDUNITELEMENT",1765591967:"IFCDERIVEDUNIT",1072939445:"IFCDATEANDTIME",3510044353:"IFCCURVESTYLEFONTPATTERN",2367409068:"IFCCURVESTYLEFONTANDSCALING",1105321065:"IFCCURVESTYLEFONT",539742890:"IFCCURRENCYRELATIONSHIP",602808272:"IFCCOSTVALUE",1065062679:"IFCCOORDINATEDUNIVERSALTIMEOFFSET",347226245:"IFCCONSTRAINTRELATIONSHIP",613356794:"IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",1658513725:"IFCCONSTRAINTAGGREGATIONRELATIONSHIP",1959218052:"IFCCONSTRAINT",2732653382:"IFCCONNECTIONSURFACEGEOMETRY",4257277454:"IFCCONNECTIONPORTGEOMETRY",2614616156:"IFCCONNECTIONPOINTGEOMETRY",2859738748:"IFCCONNECTIONGEOMETRY",3264961684:"IFCCOLOURSPECIFICATION",3639012971:"IFCCLASSIFICATIONNOTATIONFACET",938368621:"IFCCLASSIFICATIONNOTATION",1098599126:"IFCCLASSIFICATIONITEMRELATIONSHIP",1767535486:"IFCCLASSIFICATIONITEM",747523909:"IFCCLASSIFICATION",622194075:"IFCCALENDARDATE",2069777674:"IFCBOUNDARYNODECONDITIONWARPING",1387855156:"IFCBOUNDARYNODECONDITION",3367102660:"IFCBOUNDARYFACECONDITION",1560379544:"IFCBOUNDARYEDGECONDITION",4037036970:"IFCBOUNDARYCONDITION",3869604511:"IFCAPPROVALRELATIONSHIP",390851274:"IFCAPPROVALPROPERTYRELATIONSHIP",2080292479:"IFCAPPROVALACTORRELATIONSHIP",130549933:"IFCAPPROVAL",1110488051:"IFCAPPLIEDVALUERELATIONSHIP",411424972:"IFCAPPLIEDVALUE",639542469:"IFCAPPLICATION",618182010:"IFCADDRESS",3630933823:"IFCACTORROLE",599546466:"FILE_DESCRIPTION",1390159747:"FILE_NAME",1109904537:"FILE_SCHEMA"};class Ee{static async getUnits(n){var i,o,I;const{IFCUNITASSIGNMENT:t}=Q,e=await n.getAllPropertiesOfType(t);if(!e)return 1;const s=Object.keys(e),E=e[parseInt(s[0],10)];for(const c of E.Units){if(c.value===void 0||c.value===null)continue;const C=await n.getProperties(c.value);if(!C||!C.UnitType||!C.UnitType.value||C.UnitType.value!=="LENGTHUNIT")continue;let a=1,R=1;return C.Name.value==="METRE"&&(R=1),C.Name.value==="FOOT"&&(R=.3048),((i=C.Prefix)==null?void 0:i.value)==="MILLI"?a=.001:((o=C.Prefix)==null?void 0:o.value)==="CENTI"?a=.01:((I=C.Prefix)==null?void 0:I.value)==="DECI"&&(a=.1),R*a}return 1}static async findItemByGuid(n,t){var s;const e=n.getAllPropertiesIDs();for(const E of e){const i=await n.getProperties(E);if(i&&((s=i.GlobalId)==null?void 0:s.value)===t)return i}return null}static async getRelationMap(n,t,e){var I;const E=e??(async()=>{}),i={},o=n.getAllPropertiesIDs();for(const c of o){const C=await n.getProperties(c);if(!C)continue;const T=C.type===t,a=Object.keys(C).find(F=>F.startsWith("Relating")),R=Object.keys(C).find(F=>F.startsWith("Related"));if(!(T&&a&&R))continue;const l=await n.getProperties((I=C[a])==null?void 0:I.value),S=C[R];if(!l||!S||!(S&&Array.isArray(S)))continue;const N=S.map(F=>F.value);await E(l.expressID,N),i[l.expressID]=N}return i}static async getQsetQuantities(n,t,e){const E=e??(()=>{}),i=await n.getProperties(t);return!i||i.type!==Xs?null:(i.Quantities??[{}]).map(c=>(c.value&&E(c.value),c.value)).filter(c=>c!==null)}static async getPsetProps(n,t,e){const E=e??(()=>{}),i=await n.getProperties(t);return!i||i.type!==de?null:(i.HasProperties??[{}]).map(c=>(c.value&&E(c.value),c.value)).filter(c=>c!==null)}static async getPsetRel(n,t){var o;if(!await n.getProperties(t))return null;const s=await n.getAllPropertiesOfType(xe);if(!s)return null;const E=Object.values(s);let i=null;for(const I of E)((o=I.RelatingPropertyDefinition)==null?void 0:o.value)===t&&(i=I.expressID);return i}static async getQsetRel(n,t){return Ee.getPsetRel(n,t)}static async getEntityName(n,t){var i;const e=await n.getProperties(t);if(!e)return{key:null,name:null};const s=Object.keys(e).find(o=>o.endsWith("Name"))??null,E=s?(i=e[s])==null?void 0:i.value:null;return{key:s,name:E}}static async getQuantityValue(n,t){const e=await n.getProperties(t);if(!e)return{key:null,value:null};const s=Object.keys(e).find(i=>i.endsWith("Value"))??null;let E;return s===null||e[s]===void 0||e[s]===null?E=null:E=e[s].value,{key:s,value:E}}static isRel(n){return ui[n].startsWith("IFCREL")}static async attributeExists(n,t,e){const s=await n.getProperties(t);return s?Object.keys(s).includes(e):!1}static async groupEntitiesByType(n,t){var s;const e=new Map;for(const E of t){const i=await n.getProperties(E);if(!i)continue;const o=i.type;e.get(o)||e.set(o,new Set),(s=e.get(o))==null||s.add(E)}return e}}class fi{constructor(){M(this,"factor",1);M(this,"complement",1)}apply(n){const e=this.getScaleMatrix().multiply(n);n.copy(e)}setUp(n){var E,i,o;this.factor=1;const t=this.getLengthUnits(n);if(!t)return;const e=t==null,s=t.Name===void 0||t.Name===null;e||s||(t.Name.value==="FOOT"&&(this.factor=.3048),((E=t.Prefix)==null?void 0:E.value)==="MILLI"?this.complement=.001:((i=t.Prefix)==null?void 0:i.value)==="CENTI"?this.complement=.01:((o=t.Prefix)==null?void 0:o.value)==="DECI"&&(this.complement=.01))}getLengthUnits(n){try{const e=n.GetLineIDsWithType(0,zs).get(0),s=n.GetLine(0,e);for(const E of s.Units){if(!E||E.value===null||E.value===void 0)continue;const i=n.GetLine(0,E.value);if(i.UnitType&&i.UnitType.value==="LENGTHUNIT")return i}return null}catch{return console.log("Could not get units"),null}}getScaleMatrix(){const n=this.factor;return new $().fromArray([n,0,0,0,0,n,0,0,0,0,n,0,0,0,0,1])}}class Ni{constructor(){M(this,"itemsByFloor",{});M(this,"_units",new fi)}setUp(n){this._units.setUp(n),this.cleanUp();try{const t=n.GetLineIDsWithType(0,Ge),e=new Set,s=n.GetLineIDsWithType(0,xt);for(let c=0;c<s.size();c++)e.add(s.get(c));const E=n.GetLineIDsWithType(0,Ye),i=E.size();for(let c=0;c<i;c++){const C=E.get(c),T=n.GetLine(0,C);if(!T||!T.RelatingObject||!T.RelatedObjects)continue;const a=T.RelatingObject.value,R=T.RelatedObjects;for(const l of R){const S=l.value;e.has(S)&&(this.itemsByFloor[S]=a)}}const o={},I=t.size();for(let c=0;c<I;c++){const C=t.get(c),T=n.GetLine(0,C);if(!T||!T.RelatingStructure||!T.RelatedElements)continue;const a=T.RelatingStructure.value,R=T.RelatedElements;if(e.has(a))for(const l of R){o[a]||(o[a]=[]);const S=l.value;o[a].push(S)}else for(const l of R){const S=l.value;this.itemsByFloor[S]=a}}for(const c in o){const C=this.itemsByFloor[c];if(C!==void 0){const T=o[c];for(const a of T)this.itemsByFloor[a]=C}}for(let c=0;c<i;c++){const C=E.get(c),T=n.GetLine(0,C);if(!T||!T.RelatingObject||!T.RelatedObjects)continue;const a=T.RelatingObject.value,R=T.RelatedObjects;for(const l of R){const S=l.value,N=this.itemsByFloor[a];N!==void 0&&(this.itemsByFloor[S]=N)}}}catch{console.log("Could not get floors.")}}cleanUp(){this.itemsByFloor={}}}class Oi{constructor(){M(this,"includeProperties",!0);M(this,"optionalCategories",[xt]);M(this,"coordinate",!0);M(this,"wasm",{path:"",absolute:!1,logLevel:ks.LOG_LEVEL_OFF});M(this,"excludedCategories",new Set);M(this,"includedCategories",new Set);M(this,"saveLocations",!1);M(this,"webIfc",{COORDINATE_TO_ORIGIN:!0});M(this,"autoSetWasm",!0);M(this,"customLocateFileHandler",null)}}class Si{constructor(){M(this,"defLineMat",new $s({color:16777215}))}read(n){const t=n.GetAllAlignments(0),e=n.GetAllCrossSections2D(0),s=n.GetAllCrossSections3D(0),E={IfcAlignment:t,IfcCrossSection2D:e,IfcCrossSection3D:s};return this.get(E)}get(n){if(n.IfcAlignment){const t=new Map;for(const e of n.IfcAlignment){const s=new js;s.absolute=this.getCurves(e.curve3D,s),s.horizontal=this.getCurves(e.horizontal,s),s.vertical=this.getCurves(e.vertical,s),t.set(t.size,s)}return{alignments:t,coordinationMatrix:new $}}}getCurves(n,t){const e=[];let s=0;for(const E of n){const i={};if(E.data)for(const a of E.data){const[R,l]=a.split(": "),S=parseFloat(l);i[R]=S||l}const{points:o}=E,I=new Float32Array(o.length*3);for(let a=0;a<o.length;a++){const{x:R,y:l,z:S}=o[a];I[a*3]=R,I[a*3+1]=l,I[a*3+2]=S||0}const c=new Bt(I,3),C=new Ks;C.setAttribute("position",c);const T=new qs(s,i,t,C,this.defLineMat);e.push(T.curve),s++}return e}}class Li{getNameInfo(n){var T;const t={},{arguments:e}=n.GetHeaderLine(0,Qs)||{};if(!e)return t;const[s,E,i,o,I,c,C]=e;if(s!=null&&s.value&&(t.name=s.value),E!=null&&E.value&&(t.creationDate=new Date(E.value)),i){t.author={};const[a,R]=i;a!=null&&a.value&&(t.author.name=a.value),R!=null&&R.value&&(t.author.email=R.value)}return(T=o[0])!=null&&T.value&&(t.organization=o[0].value),I!=null&&I.value&&(t.preprocessorVersion=I==null?void 0:I.value),c!=null&&c.value&&(t.originatingSystem=c==null?void 0:c.value),C!=null&&C.value&&(t.authorization=C==null?void 0:C.value),t}getDescriptionInfo(n){var i;const t={},{arguments:e}=n.GetHeaderLine(0,Zs)||{};if(!e)return t;const[s,E]=e;if((i=s[0])!=null&&i.value){const o=s[0].value.match(/\[([^\]]+)\]/);o&&o[1]&&(t.viewDefinition=o[1])}return E!=null&&E.value&&(t.implementationLevel=E.value),t}}class Pi{static get(n,t){const e=[Ps,ps,ds,Ms,xt,Js,tn,en,sn],s=n.data;for(const E of e){const i=t.GetLineIDsWithType(0,E),o=i.size();for(let I=0;I<o;I++){const c=i.get(I);s.has(c)||s.set(c,[[],[0,E]])}}}}const wt=class wt extends Gt{constructor(t){super(t);M(this,"onDisposed",new x);M(this,"onIfcStartedLoading",new x);M(this,"onSetup",new x);M(this,"settings",new Oi);M(this,"webIfc",new We);M(this,"enabled",!0);M(this,"_material",new Xe);M(this,"_spatialTree",new Ni);M(this,"_metaData",new Li);M(this,"_fragmentInstances",new Map);M(this,"_civil",new Si);M(this,"_visitedFragments",new Map);M(this,"_materialT",new Xe({transparent:!0,opacity:.5}));this.components.add(wt.uuid,this),this.settings.excludedCategories.add(nn)}dispose(){this.webIfc=null,this.onDisposed.trigger(wt.uuid),this.onDisposed.reset()}async setup(t){this.settings={...this.settings,...t},this.settings.autoSetWasm&&await this.autoSetWasm(),this.onSetup.trigger()}async load(t,e=!0){const s=performance.now();this.onIfcStartedLoading.trigger(),await this.readIfcFile(t);const E=await this.getAllGeometries(),o=await this.components.get(we).export(this.webIfc,0);E.setLocalProperties(o);const I=this.components.get(Yt);I.groups.set(E.uuid,E);for(const c of E.items)I.list.set(c.id,c),c.mesh.uuid=c.id,c.group=E;I.onFragmentsLoaded.trigger(E),e&&I.coordinate([E]);for(const[c]of E.data){const C=o[c];if(!C||!C.GlobalId)continue;const T=C.GlobalId.value||C.GlobalId;E.globalToExpressIDs.set(T,c)}return Pi.get(E,this.webIfc),this.cleanUp(),console.log(`Streaming the IFC took ${performance.now()-s} ms!`),E}async readIfcFile(t){const{path:e,absolute:s,logLevel:E}=this.settings.wasm;return this.webIfc.SetWasmPath(e,s),await this.webIfc.Init(this.settings.customLocateFileHandler||void 0),E&&this.webIfc.SetLogLevel(E),this.webIfc.OpenModel(t,this.settings.webIfc)}cleanUp(){try{this.webIfc.Dispose()}catch{console.log("Web-ifc wasn't disposed.")}this.webIfc=null,this.webIfc=new We,this._visitedFragments.clear(),this._fragmentInstances.clear()}async getAllGeometries(){this._spatialTree.setUp(this.webIfc);const t=this.webIfc.GetIfcEntityList(0),e=new En;e.ifcMetadata={name:"",description:"",...this._metaData.getNameInfo(this.webIfc),...this._metaData.getDescriptionInfo(this.webIfc),schema:this.webIfc.GetModelSchema(0)||"IFC2X3",maxExpressID:this.webIfc.GetMaxExpressID(0)};const s=[];for(const i of t){if(!this.webIfc.IsIfcElement(i)&&i!==xt)continue;const o=this.settings.includedCategories;if(o.size>0&&!o.has(i))continue;if(this.settings.excludedCategories.has(i))continue;const I=this.webIfc.GetLineIDsWithType(0,i),c=I.size();for(let C=0;C<c;C++){const T=I.get(C);s.push(T);const a=this._spatialTree.itemsByFloor[T]||0;e.data.set(T,[[],[a,i]])}}this._spatialTree.cleanUp(),this.webIfc.StreamMeshes(0,s,i=>{this.getMesh(i,e)});for(const i of this._visitedFragments){const{index:o,fragment:I}=i[1];e.keyFragments.set(o,I.id)}for(const i of e.items){const o=this._fragmentInstances.get(i.id);if(!o)throw new Error("Fragment not found!");const I=[];for(const[c,C]of o)I.push(C);i.add(I)}const E=this.webIfc.GetCoordinationMatrix(0);return e.coordinationMatrix.fromArray(E),e.civilData=this._civil.read(this.webIfc),e}getMesh(t,e){const s=t.geometries.size(),E=t.expressID;for(let i=0;i<s;i++){const o=t.geometries.get(i),{x:I,y:c,z:C,w:T}=o.color,a=T!==1,{geometryExpressID:R}=o,l=`${R}-${a}`;if(!this._visitedFragments.has(l)){const f=this.getGeometry(this.webIfc,R),L=a?this._materialT:this._material,P=new on(f,L,1);e.add(P.mesh),e.items.push(P);const p=this._visitedFragments.size;this._visitedFragments.set(l,{index:p,fragment:P})}const S=new rn().setRGB(I,c,C,"srgb"),N=new $;N.fromArray(o.flatTransformation);const F=this._visitedFragments.get(l);if(F===void 0)throw new Error("Error getting geometry data for streaming!");const u=e.data.get(E);if(!u)throw new Error("Data not found!");u[0].push(F.index);const{fragment:O}=F;this._fragmentInstances.has(O.id)||this._fragmentInstances.set(O.id,new Map);const A=this._fragmentInstances.get(O.id);if(!A)throw new Error("Instances not found!");if(A.has(E)){const f=A.get(E);if(!f)throw new Error("Instance not found!");f.transforms.push(N),f.colors&&f.colors.push(S)}else A.set(E,{id:E,transforms:[N],colors:[S]})}}getGeometry(t,e){const s=t.GetGeometry(0,e),E=t.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),i=t.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize()),o=new Float32Array(i.length/2),I=new Float32Array(i.length/2);for(let a=0;a<i.length;a+=6)o[a/2]=i[a],o[a/2+1]=i[a+1],o[a/2+2]=i[a+2],I[a/2]=i[a+3],I[a/2+1]=i[a+4],I[a/2+2]=i[a+5];const c=new pe,C=new Bt(o,3),T=new Bt(I,3);return c.setAttribute("position",C),c.setAttribute("normal",T),c.setIndex(Array.from(E)),s.delete(),c}async autoSetWasm(){const t=await fetch(`https://unpkg.com/@thatopen/components@${ne.release}/package.json`);if(!t.ok){console.warn("Couldn't get openbim-components package.json. Set wasm settings manually.");return}const e=await t.json();if(!("web-ifc"in e.peerDependencies))console.warn("Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually.");else{const s=e.peerDependencies["web-ifc"];this.settings.wasm.path=`https://unpkg.com/web-ifc@${s}/`,this.settings.wasm.absolute=!0}}};M(wt,"uuid","a659add7-1418-4771-a0d6-7d4d438e4624");let oe=wt;const nt=class nt extends Gt{constructor(t){super(t);M(this,"onDisposed",new x);M(this,"onRequestFile",new x);M(this,"ifcToExport",null);M(this,"onElementToPset",new x);M(this,"onPropToPset",new x);M(this,"onPsetRemoved",new x);M(this,"onDataChanged",new x);M(this,"wasm",{path:"/",absolute:!1});M(this,"enabled",!0);M(this,"attributeListeners",{});M(this,"selectedModel");M(this,"changeMap",{});this.components.add(nt.uuid,this)}dispose(){this.selectedModel=void 0,this.attributeListeners={},this.changeMap={},this.onElementToPset.reset(),this.onPropToPset.reset(),this.onPsetRemoved.reset(),this.onDataChanged.reset(),this.onDisposed.trigger(nt.uuid),this.onDisposed.reset()}static getIFCSchema(t){const e=t.ifcMetadata.schema;if(!e)throw new Error("IFC Schema not found");return e.startsWith("IFC2X3")?"IFC2X3":e.startsWith("IFC4")&&e.replace("IFC4","")===""?"IFC4":e.startsWith("IFC4X3")?"IFC4X3":e}async setData(t,...e){for(const s of e){const E=s.expressID;E&&(await t.setProperties(E,s),this.registerChange(t,E))}}async newPset(t,e,s){const E=nt.getIFCSchema(t),{ownerHistoryHandle:i}=await this.getOwnerHistory(t),o=this.newGUID(t),I=new Q[E].IfcLabel(e),c=s?new Q[E].IfcText(s):null,C=new Q[E].IfcPropertySet(o,i,I,c,[]);C.expressID=this.increaseMaxID(t);const T=this.newGUID(t),a=new Q[E].IfcRelDefinesByProperties(T,i,null,null,[],new bt(C.expressID));return a.expressID=this.increaseMaxID(t),await this.setData(t,C,a),{pset:C,rel:a}}async removePset(t,...e){for(const s of e){const E=await t.getProperties(s);if((E==null?void 0:E.type)!==de)continue;const i=await Ee.getPsetRel(t,s);if(i&&(await t.setProperties(i,null),this.registerChange(t,i)),E){for(const o of E.HasProperties)await t.setProperties(o.value,null);await t.setProperties(s,null),this.onPsetRemoved.trigger({model:t,psetID:s}),this.registerChange(t,s)}}}newSingleStringProperty(t,e,s,E){return this.newSingleProperty(t,e,s,E)}newSingleNumericProperty(t,e,s,E){return this.newSingleProperty(t,e,s,E)}newSingleBooleanProperty(t,e,s,E){return this.newSingleProperty(t,e,s,E)}async removePsetProp(t,e,s){const E=await t.getProperties(e),i=await t.getProperties(s);!E||!i||E.type===de&&i&&(E.HasProperties=E.HasProperties.filter(o=>o.value!==s),await t.setProperties(s,null),this.registerChange(t,e,s))}async addElementToPset(t,e,...s){const E=await Ee.getPsetRel(t,e);if(!E)return;const i=await t.getProperties(E);if(!i)return;for(const I of s){const c=new bt(I);i.RelatedObjects.push(c),this.onElementToPset.trigger({model:t,psetID:e,elementID:I})}this.registerChange(t,e);const o=this.components.get(ie);for(const I of s)o.addEntityRelations(t,I,"IsDefinedBy",e)}async addPropToPset(t,e,...s){const E=await t.getProperties(e);if(E){for(const i of s){if(E.HasProperties.includes(i))continue;const o=new bt(i);E.HasProperties.push(o),this.onPropToPset.trigger({model:t,psetID:e,propID:i})}this.registerChange(t,e)}}async saveToIfc(t,e){const s=this.components.get(oe),E=s.webIfc,i=await s.readIfcFile(e),o=this.changeMap[t.uuid]??[];for(const c of o){const C=await t.getProperties(c);if(C)try{E.WriteLine(i,C)}catch{}else try{E.DeleteLine(i,c)}catch{}}const I=E.SaveModel(i);return s.webIfc.CloseModel(i),s.cleanUp(),I}async setAttributeListener(t,e,s){this.attributeListeners[t.uuid]||(this.attributeListeners[t.uuid]={});const E=this.attributeListeners[t.uuid][e]?this.attributeListeners[t.uuid][e][s]:null;if(E)return E;const i=await t.getProperties(e);if(!i)throw new Error(`Entity with expressID ${e} doesn't exists.`);const o=i[s];if(Array.isArray(o)||!o)throw new Error(`Attribute ${s} is array or null, and it can't have a listener.`);const I=o.value;if(I===void 0||I==null)throw new Error(`Attribute ${s} has a badly defined handle.`);const c=new x;return Object.defineProperty(i[s],"value",{get(){return this._value},async set(C){this._value=C,c.trigger(C)}}),i[s].value=I,this.attributeListeners[t.uuid][e]||(this.attributeListeners[t.uuid][e]={}),this.attributeListeners[t.uuid][e][s]=c,c}increaseMaxID(t){return t.ifcMetadata.maxExpressID++,t.ifcMetadata.maxExpressID}newGUID(t){const e=nt.getIFCSchema(t);return new Q[e].IfcGloballyUniqueId(se.create())}async getOwnerHistory(t){const e=await t.getAllPropertiesOfType(In);if(!e)throw new Error("No OwnerHistory was found.");const s=Object.keys(e).map(o=>parseInt(o,10)),E=e[s[0]],i=new bt(E.expressID);return{ownerHistory:E,ownerHistoryHandle:i}}registerChange(t,...e){this.changeMap[t.uuid]||(this.changeMap[t.uuid]=new Set);for(const s of e)this.changeMap[t.uuid].add(s),this.onDataChanged.trigger({model:t,expressID:s})}async newSingleProperty(t,e,s,E){const i=nt.getIFCSchema(t),o=new Q[i].IfcIdentifier(s),I=new Q[i][e](E),c=new Q[i].IfcPropertySingleValue(o,null,I,null);return c.expressID=this.increaseMaxID(t),await this.setData(t,c),c}};M(nt,"uuid","58c2d9f0-183c-48d6-a402-dfcf5b9a34df");let Be=nt;const gs=new ne,ms=gs.get(oe);await ms.setup();const pi=await fetch("https://thatopen.github.io/engine_components/resources/small.ifc"),ws=await pi.arrayBuffer(),ot=await ms.load(new Uint8Array(ws)),Ot=gs.get(Be),{pset:Bs}=await Ot.newPset(ot,"CalculatedQuantities"),di=await Ot.newSingleNumericProperty(ot,"IfcReal","Volume",12.25);await Ot.addPropToPset(ot,Bs.expressID,di.expressID);await Ot.addElementToPset(ot,Bs.expressID,186);const Pe=await ot.getProperties(186);Pe&&(Pe.Name.value="New Wall Name",await Ot.setData(ot,Pe));const Mi=await Ot.saveToIfc(ot,new Uint8Array(ws)),Ys=new File([Mi],"small-modified.ifc"),ve=document.createElement("a");ve.href=URL.createObjectURL(Ys);ve.download=Ys.name;URL.revokeObjectURL(ve.href);
