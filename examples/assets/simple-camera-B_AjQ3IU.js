var Ys=Object.defineProperty;var Ns=(n,t,e)=>t in n?Ys(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var R=(n,t,e)=>(Ns(n,typeof t!="symbol"?t+"":t,e),e);import{h as vs,V as D,k as Tt,j as Ls,v as ct,T as Qt,t as Ds,f as lt,B as et,aD as Zs,a9 as Xs,ax as ts,b as Ss,ay as qs,_ as $s,g as es,C as Ae,S as Ks,D as Ws,A as Qs,O as Gs,a4 as js,a5 as Js,u as ti,a6 as ei,a7 as si,a2 as ii,w as ni}from"./index-chvdFvuw.js";const Ms=0,oi=1,ri=2,ss=2,Ce=1.25,is=1,Te=6*4+4+4,we=65535,ai=Math.pow(2,-24),Pe=Symbol("SKIP_GENERATION");function ci(n){return n.index?n.index.count:n.attributes.position.count}function Ft(n){return ci(n)/3}function li(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function hi(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=li(e,s);n.setIndex(new vs(i,1));for(let r=0;r<e;r++)i[r]=r}}function Bs(n){const t=Ft(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,r=Math.max(0,s),o=Math.min(t,i)-r;return[{offset:Math.floor(r),count:Math.floor(o)}]}function Fs(n){if(!n.groups||!n.groups.length)return Bs(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,r=(s.start+s.count)/3;for(const a of n.groups){const c=a.start/3,d=(a.start+a.count)/3;e.add(Math.max(i,c)),e.add(Math.min(r,d))}const o=Array.from(e.values()).sort((a,c)=>a-c);for(let a=0;a<o.length-1;a++){const c=o[a],d=o[a+1];t.push({offset:Math.floor(c),count:Math.floor(d-c)})}return t}function ui(n){if(n.groups.length===0)return!1;const t=Ft(n),e=Fs(n).sort((r,o)=>r.offset-o.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:r})=>i+=r),t!==i}function Y(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function fi(n){n[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0}function ns(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function os(n,t){t.set(n)}function rs(n,t,e){let s,i;for(let r=0;r<3;r++){const o=r+3;s=n[r],i=t[r],e[r]=s<i?s:i,s=n[o],i=t[o],e[o]=s>i?s:i}}function te(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],r=t[n+2*s+1],o=i-r,a=i+r;o<e[s]&&(e[s]=o),a>e[s+3]&&(e[s+3]=a)}}function Ht(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}function be(n,t,e,s,i=null){let r=1/0,o=1/0,a=1/0,c=-1/0,d=-1/0,f=-1/0,u=1/0,l=1/0,p=1/0,y=-1/0,O=-1/0,T=-1/0;const m=i!==null;for(let g=t*6,E=(t+e)*6;g<E;g+=6){const h=n[g+0],_=n[g+1],x=h-_,w=h+_;x<r&&(r=x),w>c&&(c=w),m&&h<u&&(u=h),m&&h>y&&(y=h);const C=n[g+2],P=n[g+3],b=C-P,v=C+P;b<o&&(o=b),v>d&&(d=v),m&&C<l&&(l=C),m&&C>O&&(O=C);const U=n[g+4],L=n[g+5],S=U-L,z=U+L;S<a&&(a=S),z>f&&(f=z),m&&U<p&&(p=U),m&&U>T&&(T=U)}s[0]=r,s[1]=o,s[2]=a,s[3]=c,s[4]=d,s[5]=f,m&&(i[0]=u,i[1]=l,i[2]=p,i[3]=y,i[4]=O,i[5]=T)}function di(n,t,e,s){let i=1/0,r=1/0,o=1/0,a=-1/0,c=-1/0,d=-1/0;for(let f=t*6,u=(t+e)*6;f<u;f+=6){const l=n[f+0];l<i&&(i=l),l>a&&(a=l);const p=n[f+2];p<r&&(r=p),p>c&&(c=p);const y=n[f+4];y<o&&(o=y),y>d&&(d=y)}s[0]=i,s[1]=r,s[2]=o,s[3]=a,s[4]=c,s[5]=d}function pi(n,t){fi(t);const e=n.attributes.position,s=n.index?n.index.array:null,i=Ft(n),r=new Float32Array(i*6),o=e.normalized,a=e.array,c=e.offset||0;let d=3;e.isInterleavedBufferAttribute&&(d=e.data.stride);const f=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,p=u*6;let y=l+0,O=l+1,T=l+2;s&&(y=s[y],O=s[O],T=s[T]),o||(y=y*d+c,O=O*d+c,T=T*d+c);for(let m=0;m<3;m++){let g,E,h;o?(g=e[f[m]](y),E=e[f[m]](O),h=e[f[m]](T)):(g=a[y+m],E=a[O+m],h=a[T+m]);let _=g;E<_&&(_=E),h<_&&(_=h);let x=g;E>x&&(x=E),h>x&&(x=h);const w=(x-_)/2,C=m*2;r[p+C+0]=_+w,r[p+C+1]=w+(Math.abs(_)+w)*ai,_<t[m]&&(t[m]=_),x>t[m+3]&&(t[m+3]=x)}}return r}const at=32,_i=(n,t)=>n.candidate-t.candidate,ut=new Array(at).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),ee=new Float32Array(6);function mi(n,t,e,s,i,r){let o=-1,a=0;if(r===Ms)o=ns(t),o!==-1&&(a=(t[o]+t[o+3])/2);else if(r===oi)o=ns(n),o!==-1&&(a=yi(e,s,i,o));else if(r===ri){const c=Ht(n);let d=Ce*i;const f=s*6,u=(s+i)*6;for(let l=0;l<3;l++){const p=t[l],T=(t[l+3]-p)/at;if(i<at/4){const m=[...ut];m.length=i;let g=0;for(let h=f;h<u;h+=6,g++){const _=m[g];_.candidate=e[h+2*l],_.count=0;const{bounds:x,leftCacheBounds:w,rightCacheBounds:C}=_;for(let P=0;P<3;P++)C[P]=1/0,C[P+3]=-1/0,w[P]=1/0,w[P+3]=-1/0,x[P]=1/0,x[P+3]=-1/0;te(h,e,x)}m.sort(_i);let E=i;for(let h=0;h<E;h++){const _=m[h];for(;h+1<E&&m[h+1].candidate===_.candidate;)m.splice(h+1,1),E--}for(let h=f;h<u;h+=6){const _=e[h+2*l];for(let x=0;x<E;x++){const w=m[x];_>=w.candidate?te(h,e,w.rightCacheBounds):(te(h,e,w.leftCacheBounds),w.count++)}}for(let h=0;h<E;h++){const _=m[h],x=_.count,w=i-_.count,C=_.leftCacheBounds,P=_.rightCacheBounds;let b=0;x!==0&&(b=Ht(C)/c);let v=0;w!==0&&(v=Ht(P)/c);const U=is+Ce*(b*x+v*w);U<d&&(o=l,d=U,a=_.candidate)}}else{for(let E=0;E<at;E++){const h=ut[E];h.count=0,h.candidate=p+T+E*T;const _=h.bounds;for(let x=0;x<3;x++)_[x]=1/0,_[x+3]=-1/0}for(let E=f;E<u;E+=6){let x=~~((e[E+2*l]-p)/T);x>=at&&(x=at-1);const w=ut[x];w.count++,te(E,e,w.bounds)}const m=ut[at-1];os(m.bounds,m.rightCacheBounds);for(let E=at-2;E>=0;E--){const h=ut[E],_=ut[E+1];rs(h.bounds,_.rightCacheBounds,h.rightCacheBounds)}let g=0;for(let E=0;E<at-1;E++){const h=ut[E],_=h.count,x=h.bounds,C=ut[E+1].rightCacheBounds;_!==0&&(g===0?os(x,ee):rs(x,ee,ee)),g+=_;let P=0,b=0;g!==0&&(P=Ht(ee)/c);const v=i-g;v!==0&&(b=Ht(C)/c);const U=is+Ce*(P*g+b*v);U<d&&(o=l,d=U,a=h.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}function yi(n,t,e,s){let i=0;for(let r=t,o=t+e;r<o;r++)i+=n[r*6+s*2];return i/e}class se{constructor(){}}function gi(n,t,e,s,i,r){let o=s,a=s+i-1;const c=r.pos,d=r.axis*2;for(;;){for(;o<=a&&e[o*6+d]<c;)o++;for(;o<=a&&e[a*6+d]>=c;)a--;if(o<a){for(let f=0;f<3;f++){let u=t[o*3+f];t[o*3+f]=t[a*3+f],t[a*3+f]=u}for(let f=0;f<6;f++){let u=e[o*6+f];e[o*6+f]=e[a*6+f],e[a*6+f]=u}o++,a--}else return o}}function Ti(n,t,e,s,i,r){let o=s,a=s+i-1;const c=r.pos,d=r.axis*2;for(;;){for(;o<=a&&e[o*6+d]<c;)o++;for(;o<=a&&e[a*6+d]>=c;)a--;if(o<a){let f=n[o];n[o]=n[a],n[a]=f;for(let u=0;u<6;u++){let l=e[o*6+u];e[o*6+u]=e[a*6+u],e[a*6+u]=l}o++,a--}else return o}}function Ei(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,r=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),o=s?new Uint32Array(r):new Uint16Array(r);for(let a=0,c=o.length;a<c;a++)o[a]=a;return o}function xi(n,t){const e=n.geometry,s=e.index?e.index.array:null,i=t.maxDepth,r=t.verbose,o=t.maxLeafTris,a=t.strategy,c=t.onProgress,d=Ft(e),f=n._indirectBuffer;let u=!1;const l=new Float32Array(6),p=new Float32Array(6),y=pi(e,l),O=t.indirect?Ti:gi,T=[],m=t.indirect?Bs(e):Fs(e);if(m.length===1){const h=m[0],_=new se;_.boundingData=l,di(y,h.offset,h.count,p),E(_,h.offset,h.count,p),T.push(_)}else for(let h of m){const _=new se;_.boundingData=new Float32Array(6),be(y,h.offset,h.count,_.boundingData,p),E(_,h.offset,h.count,p),T.push(_)}return T;function g(h){c&&c(h/d)}function E(h,_,x,w=null,C=0){if(!u&&C>=i&&(u=!0,r&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),x<=o||C>=i)return g(_+x),h.offset=_,h.count=x,h;const P=mi(h.boundingData,w,y,_,x,a);if(P.axis===-1)return g(_+x),h.offset=_,h.count=x,h;const b=O(f,s,y,_,x,P);if(b===_||b===_+x)g(_+x),h.offset=_,h.count=x;else{h.splitAxis=P.axis;const v=new se,U=_,L=b-_;h.left=v,v.boundingData=new Float32Array(6),be(y,U,L,v.boundingData,p),E(v,U,L,p,C+1);const S=new se,z=b,N=x-L;h.right=S,S.boundingData=new Float32Array(6),be(y,z,N,S.boundingData,p),E(S,z,N,p,C+1)}return h}}function wi(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=Ei(e,t.useSharedArrayBuffer),ui(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||hi(e,t);const s=xi(n,t);let i,r,o;const a=[],c=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const l=s[u];let p=d(l);const y=new c(Te*p);i=new Float32Array(y),r=new Uint32Array(y),o=new Uint16Array(y),f(0,l),a.push(y)}n._roots=a;return;function d(u){return u.count?1:1+d(u.left)+d(u.right)}function f(u,l){const p=u/4,y=u/2,O=!!l.count,T=l.boundingData;for(let m=0;m<6;m++)i[p+m]=T[m];if(O){const m=l.offset,g=l.count;return r[p+6]=m,o[y+14]=g,o[y+15]=we,u+Te}else{const m=l.left,g=l.right,E=l.splitAxis;let h;if(h=f(u+Te,m),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[p+6]=h/4,h=f(h,g),r[p+7]=E,h}}}class ht{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,o=t.length;r<o;r++){const c=t[r][e];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,o=e.length;r<o;r++){const a=e[r],c=t.dot(a);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ht.prototype.setFromBox=function(){const n=new D;return function(e,s){const i=s.min,r=s.max;let o=1/0,a=-1/0;for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)for(let f=0;f<=1;f++){n.x=i.x*c+r.x*(1-c),n.y=i.y*d+r.y*(1-d),n.z=i.z*f+r.z*(1-f);const u=e.dot(n);o=Math.min(u,o),a=Math.max(u,a)}this.min=o,this.max=a}}();const Oi=function(){const n=new D,t=new D,e=new D;return function(i,r,o){const a=i.start,c=n,d=r.start,f=t;e.subVectors(a,d),n.subVectors(i.end,i.start),t.subVectors(r.end,r.start);const u=e.dot(f),l=f.dot(c),p=f.dot(f),y=e.dot(c),T=c.dot(c)*p-l*l;let m,g;T!==0?m=(u*l-y*p)/T:m=0,g=(u+m*l)/p,o.x=m,o.y=g}}(),Ge=function(){const n=new Tt,t=new D,e=new D;return function(i,r,o,a){Oi(i,r,n);let c=n.x,d=n.y;if(c>=0&&c<=1&&d>=0&&d<=1){i.at(c,o),r.at(d,a);return}else if(c>=0&&c<=1){d<0?r.at(0,a):r.at(1,a),i.closestPointToPoint(a,!0,o);return}else if(d>=0&&d<=1){c<0?i.at(0,o):i.at(1,o),r.closestPointToPoint(o,!0,a);return}else{let f;c<0?f=i.start:f=i.end;let u;d<0?u=r.start:u=r.end;const l=t,p=e;if(i.closestPointToPoint(u,!0,t),r.closestPointToPoint(f,!0,e),l.distanceToSquared(u)<=p.distanceToSquared(f)){o.copy(l),a.copy(u);return}else{o.copy(f),a.copy(p);return}}}}(),Ai=function(){const n=new D,t=new D,e=new Ls,s=new ct;return function(r,o){const{radius:a,center:c}=r,{a:d,b:f,c:u}=o;if(s.start=d,s.end=f,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a||(s.start=d,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a)||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=a))return!0;const O=o.getPlane(e);if(Math.abs(O.distanceToPoint(c))<=a){const m=O.projectPoint(c,t);if(o.containsPoint(m))return!0}return!1}}(),Ci=1e-15;function Ue(n){return Math.abs(n)<Ci}class nt extends Qt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new D),this.satBounds=new Array(4).fill().map(()=>new ht),this.points=[this.a,this.b,this.c],this.sphere=new Ds,this.plane=new Ls,this.needsUpdate=!0}intersectsSphere(t){return Ai(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,o=this.satBounds,a=r[0],c=o[0];this.getNormal(a),c.setFromPoints(a,i);const d=r[1],f=o[1];d.subVectors(t,e),f.setFromPoints(d,i);const u=r[2],l=o[2];u.subVectors(e,s),l.setFromPoints(u,i);const p=r[3],y=o[3];p.subVectors(s,t),y.setFromPoints(p,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}nt.prototype.closestPointToSegment=function(){const n=new D,t=new D,e=new ct;return function(i,r=null,o=null){const{start:a,end:c}=i,d=this.points;let f,u=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;e.start.copy(d[l]),e.end.copy(d[p]),Ge(e,i,n,t),f=n.distanceToSquared(t),f<u&&(u=f,r&&r.copy(n),o&&o.copy(t))}return this.closestPointToPoint(a,n),f=a.distanceToSquared(n),f<u&&(u=f,r&&r.copy(n),o&&o.copy(a)),this.closestPointToPoint(c,n),f=c.distanceToSquared(n),f<u&&(u=f,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(u)}}();nt.prototype.intersectsTriangle=function(){const n=new nt,t=new Array(3),e=new Array(3),s=new ht,i=new ht,r=new D,o=new D,a=new D,c=new D,d=new D,f=new ct,u=new ct,l=new ct,p=new D;function y(O,T,m){const g=O.points;let E=0,h=-1;for(let _=0;_<3;_++){const{start:x,end:w}=f;x.copy(g[_]),w.copy(g[(_+1)%3]),f.delta(o);const C=Ue(T.distanceToPoint(x));if(Ue(T.normal.dot(o))&&C){m.copy(f),E=2;break}const P=T.intersectLine(f,p);if(!P&&C&&p.copy(x),(P||C)&&!Ue(p.distanceTo(w))){if(E<=1)(E===1?m.start:m.end).copy(p),C&&(h=E);else if(E>=2){(h===1?m.start:m.end).copy(p),E=2;break}if(E++,E===2&&h===-1)break}}return E}return function(T,m=null,g=!1){this.needsUpdate&&this.update(),T.isExtendedTriangle?T.needsUpdate&&T.update():(n.copy(T),n.update(),T=n);const E=this.plane,h=T.plane;if(Math.abs(E.normal.dot(h.normal))>1-1e-10){const _=this.satBounds,x=this.satAxes;e[0]=T.a,e[1]=T.b,e[2]=T.c;for(let P=0;P<4;P++){const b=_[P],v=x[P];if(s.setFromPoints(v,e),b.isSeparated(s))return!1}const w=T.satBounds,C=T.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const b=w[P],v=C[P];if(s.setFromPoints(v,t),b.isSeparated(s))return!1}for(let P=0;P<4;P++){const b=x[P];for(let v=0;v<4;v++){const U=C[v];if(r.crossVectors(b,U),s.setFromPoints(r,t),i.setFromPoints(r,e),s.isSeparated(i))return!1}}return m&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const _=y(this,h,u);if(_===1&&T.containsPoint(u.end))return m&&(m.start.copy(u.end),m.end.copy(u.end)),!0;if(_!==2)return!1;const x=y(T,E,l);if(x===1&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(x!==2)return!1;if(u.delta(a),l.delta(c),a.dot(c)<0){let L=l.start;l.start=l.end,l.end=L}const w=u.start.dot(a),C=u.end.dot(a),P=l.start.dot(a),b=l.end.dot(a),v=C<P,U=w<b;return w!==b&&P!==C&&v===U?!1:(m&&(d.subVectors(u.start,l.start),d.dot(a)>0?m.start.copy(u.start):m.start.copy(l.start),d.subVectors(u.end,l.end),d.dot(a)<0?m.end.copy(u.end):m.end.copy(l.end)),!0)}}}();nt.prototype.distanceToPoint=function(){const n=new D;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();nt.prototype.distanceToTriangle=function(){const n=new D,t=new D,e=["a","b","c"],s=new ct,i=new ct;return function(o,a=null,c=null){const d=a||c?s:null;if(this.intersectsTriangle(o,d))return(a||c)&&(a&&d.getCenter(a),c&&d.getCenter(c)),0;let f=1/0;for(let u=0;u<3;u++){let l;const p=e[u],y=o[p];this.closestPointToPoint(y,n),l=y.distanceToSquared(n),l<f&&(f=l,a&&a.copy(n),c&&c.copy(y));const O=this[p];o.closestPointToPoint(O,n),l=O.distanceToSquared(n),l<f&&(f=l,a&&a.copy(O),c&&c.copy(n))}for(let u=0;u<3;u++){const l=e[u],p=e[(u+1)%3];s.set(this[l],this[p]);for(let y=0;y<3;y++){const O=e[y],T=e[(y+1)%3];i.set(o[O],o[T]),Ge(s,i,n,t);const m=n.distanceToSquared(t);m<f&&(f=m,a&&a.copy(n),c&&c.copy(t))}}return Math.sqrt(f)}}();class q{constructor(t,e,s){this.isOrientedBox=!0,this.min=new D,this.max=new D,this.matrix=new lt,this.invMatrix=new lt,this.points=new Array(8).fill().map(()=>new D),this.satAxes=new Array(3).fill().map(()=>new D),this.satBounds=new Array(3).fill().map(()=>new ht),this.alignedSatBounds=new Array(3).fill().map(()=>new ht),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*d|2*f|4*u,p=i[l];p.x=d?s.x:e.x,p.y=f?s.y:e.y,p.z=u?s.z:e.z,p.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,a=i[0];for(let d=0;d<3;d++){const f=o[d],u=r[d],l=1<<d,p=i[l];f.subVectors(a,p),u.setFromPoints(f,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new ht;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,a[0].isSeparated(n)||(n.min=s.y,n.max=i.y,a[1].isSeparated(n))||(n.min=s.z,n.max=i.z,a[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const d=o[c],f=r[c];if(n.setFromBox(d,e),f.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new nt,t=new Array(3),e=new ht,s=new ht,i=new D;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const a=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let l=0;l<3;l++){const p=a[l],y=c[l];if(e.setFromPoints(y,t),p.isSeparated(e))return!1}const d=o.satBounds,f=o.satAxes,u=this.points;for(let l=0;l<3;l++){const p=d[l],y=f[l];if(e.setFromPoints(y,u),p.isSeparated(e))return!1}for(let l=0;l<3;l++){const p=c[l];for(let y=0;y<4;y++){const O=f[y];if(i.crossVectors(p,O),e.setFromPoints(i,t),s.setFromPoints(i,u),e.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const n=new D;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new ct),e=new Array(12).fill().map(()=>new ct),s=new D,i=new D;return function(o,a=0,c=null,d=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||d)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),d&&d.copy(i)),0;const f=a*a,u=o.min,l=o.max,p=this.points;let y=1/0;for(let T=0;T<8;T++){const m=p[T];i.copy(m).clamp(u,l);const g=m.distanceToSquared(i);if(g<y&&(y=g,c&&c.copy(m),d&&d.copy(i),g<f))return Math.sqrt(g)}let O=0;for(let T=0;T<3;T++)for(let m=0;m<=1;m++)for(let g=0;g<=1;g++){const E=(T+1)%3,h=(T+2)%3,_=m<<E|g<<h,x=1<<T|m<<E|g<<h,w=p[_],C=p[x];t[O].set(w,C);const b=n[T],v=n[E],U=n[h],L=e[O],S=L.start,z=L.end;S[b]=u[b],S[v]=m?u[v]:l[v],S[U]=g?u[U]:l[v],z[b]=l[b],z[v]=m?u[v]:l[v],z[U]=g?u[U]:l[v],O++}for(let T=0;T<=1;T++)for(let m=0;m<=1;m++)for(let g=0;g<=1;g++){i.x=T?l.x:u.x,i.y=m?l.y:u.y,i.z=g?l.z:u.z,this.closestPointToPoint(i,s);const E=i.distanceToSquared(s);if(E<y&&(y=E,c&&c.copy(s),d&&d.copy(i),E<f))return Math.sqrt(E)}for(let T=0;T<12;T++){const m=t[T];for(let g=0;g<12;g++){const E=e[g];Ge(m,E,s,i);const h=s.distanceToSquared(i);if(h<y&&(y=h,c&&c.copy(s),d&&d.copy(i),h<f))return Math.sqrt(h)}}return Math.sqrt(y)}}();class je{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Pi extends je{constructor(){super(()=>new nt)}}const G=new Pi;function K(n,t){return t[n+15]===65535}function W(n,t){return t[n+6]}function j(n,t){return t[n+14]}function J(n){return n+8}function tt(n,t){return t[n+6]}function zs(n,t){return t[n+7]}class bi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const V=new bi;let pt,Bt;const Et=[],ie=new je(()=>new et);function Ui(n,t,e,s,i,r){pt=ie.getPrimitive(),Bt=ie.getPrimitive(),Et.push(pt,Bt),V.setBuffer(n._roots[t]);const o=Ye(0,n.geometry,e,s,i,r);V.clearBuffer(),ie.releasePrimitive(pt),ie.releasePrimitive(Bt),Et.pop(),Et.pop();const a=Et.length;return a>0&&(Bt=Et[a-1],pt=Et[a-2]),o}function Ye(n,t,e,s,i=null,r=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:d}=V;let f=n*2;if(K(f,c)){const l=W(n,d),p=j(f,c);return Y(n,a,pt),s(l,p,!1,o,r+n,pt)}else{let b=function(U){const{uint16Array:L,uint32Array:S}=V;let z=U*2;for(;!K(z,L);)U=J(U),z=U*2;return W(U,S)},v=function(U){const{uint16Array:L,uint32Array:S}=V;let z=U*2;for(;!K(z,L);)U=tt(U,S),z=U*2;return W(U,S)+j(z,L)};const l=J(n),p=tt(n,d);let y=l,O=p,T,m,g,E;if(i&&(g=pt,E=Bt,Y(y,a,g),Y(O,a,E),T=i(g),m=i(E),m<T)){y=p,O=l;const U=T;T=m,m=U,g=E}g||(g=pt,Y(y,a,g));const h=K(y*2,c),_=e(g,h,T,o+1,r+y);let x;if(_===ss){const U=b(y),S=v(y)-U;x=s(U,S,!0,o+1,r+y,g)}else x=_&&Ye(y,t,e,s,i,r,o+1);if(x)return!0;E=Bt,Y(O,a,E);const w=K(O*2,c),C=e(E,w,m,o+1,r+O);let P;if(C===ss){const U=b(O),S=v(O)-U;P=s(U,S,!0,o+1,r+O,E)}else P=C&&Ye(O,t,e,s,i,r,o+1);return!!P}}const kt=new D,ve=new D;function vi(n,t,e={},s=0,i=1/0){const r=s*s,o=i*i;let a=1/0,c=null;if(n.shapecast({boundsTraverseOrder:f=>(kt.copy(t).clamp(f.min,f.max),kt.distanceToSquared(t)),intersectsBounds:(f,u,l)=>l<a&&l<o,intersectsTriangle:(f,u)=>{f.closestPointToPoint(t,kt);const l=t.distanceToSquared(kt);return l<a&&(ve.copy(kt),a=l,c=u),l<r}}),a===1/0)return null;const d=Math.sqrt(a);return e.point?e.point.copy(ve):e.point=ve.clone(),e.distance=d,e.faceIndex=c,e}const xt=new D,wt=new D,Ot=new D,ne=new Tt,oe=new Tt,re=new Tt,as=new D,cs=new D,ls=new D,ae=new D;function Li(n,t,e,s,i,r){let o;return r===Zs?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,r!==Xs,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Di(n,t,e,s,i,r,o,a,c){xt.fromBufferAttribute(t,r),wt.fromBufferAttribute(t,o),Ot.fromBufferAttribute(t,a);const d=Li(n,xt,wt,Ot,ae,c);if(d){s&&(ne.fromBufferAttribute(s,r),oe.fromBufferAttribute(s,o),re.fromBufferAttribute(s,a),d.uv=Qt.getInterpolation(ae,xt,wt,Ot,ne,oe,re,new Tt)),i&&(ne.fromBufferAttribute(i,r),oe.fromBufferAttribute(i,o),re.fromBufferAttribute(i,a),d.uv1=Qt.getInterpolation(ae,xt,wt,Ot,ne,oe,re,new Tt)),e&&(as.fromBufferAttribute(e,r),cs.fromBufferAttribute(e,o),ls.fromBufferAttribute(e,a),d.normal=Qt.getInterpolation(ae,xt,wt,Ot,as,cs,ls,new D),d.normal.dot(n.direction)>0&&d.normal.multiplyScalar(-1));const f={a:r,b:o,c:a,normal:new D,materialIndex:0};Qt.getNormal(xt,wt,Ot,f.normal),d.face=f,d.faceIndex=r}return d}function Oe(n,t,e,s,i){const r=s*3;let o=r+0,a=r+1,c=r+2;const d=n.index;n.index&&(o=d.getX(o),a=d.getX(a),c=d.getX(c));const{position:f,normal:u,uv:l,uv1:p}=n.attributes,y=Di(e,f,u,l,p,o,a,c,t);return y?(y.faceIndex=s,i&&i.push(y),y):null}function X(n,t,e,s){const i=n.a,r=n.b,o=n.c;let a=t,c=t+1,d=t+2;e&&(a=e.getX(a),c=e.getX(c),d=e.getX(d)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),o.x=s.getX(d),o.y=s.getY(d),o.z=s.getZ(d)}function Si(n,t,e,s,i,r){const{geometry:o,_indirectBuffer:a}=n;for(let c=s,d=s+i;c<d;c++)Oe(o,t,e,c,r)}function Mi(n,t,e,s,i){const{geometry:r,_indirectBuffer:o}=n;let a=1/0,c=null;for(let d=s,f=s+i;d<f;d++){let u;u=Oe(r,t,e,d),u&&u.distance<a&&(c=u,a=u.distance)}return c}function Bi(n,t,e,s,i,r,o){const{geometry:a}=e,{index:c}=a,d=a.attributes.position;for(let f=n,u=t+n;f<u;f++){let l;if(l=f,X(o,l*3,c,d),o.needsUpdate=!0,s(o,l,i,r))return!0}return!1}function Fi(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let r,o,a,c,d=0;const f=n._roots;for(let l=0,p=f.length;l<p;l++)r=f[l],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),u(0,d),d+=r.byteLength;function u(l,p,y=!1){const O=l*2;if(a[O+15]===we){const m=o[l+6],g=a[O+14];let E=1/0,h=1/0,_=1/0,x=-1/0,w=-1/0,C=-1/0;for(let P=3*m,b=3*(m+g);P<b;P++){let v=s[P];const U=i.getX(v),L=i.getY(v),S=i.getZ(v);U<E&&(E=U),U>x&&(x=U),L<h&&(h=L),L>w&&(w=L),S<_&&(_=S),S>C&&(C=S)}return c[l+0]!==E||c[l+1]!==h||c[l+2]!==_||c[l+3]!==x||c[l+4]!==w||c[l+5]!==C?(c[l+0]=E,c[l+1]=h,c[l+2]=_,c[l+3]=x,c[l+4]=w,c[l+5]=C,!0):!1}else{const m=l+8,g=o[l+6],E=m+p,h=g+p;let _=y,x=!1,w=!1;t?_||(x=t.has(E),w=t.has(h),_=!x&&!w):(x=!0,w=!0);const C=_||x,P=_||w;let b=!1;C&&(b=u(m,p,_));let v=!1;P&&(v=u(g,p,_));const U=b||v;if(U)for(let L=0;L<3;L++){const S=m+L,z=g+L,N=c[S],zt=c[S+3],Rt=c[z],It=c[z+3];c[l+L]=N<Rt?N:Rt,c[l+L+3]=zt>It?zt:It}return U}}}const hs=new et;function mt(n,t,e,s){return Y(n,t,hs),e.intersectBox(hs,s)}function zi(n,t,e,s,i,r){const{geometry:o,_indirectBuffer:a}=n;for(let c=s,d=s+i;c<d;c++){let f=a?a[c]:c;Oe(o,t,e,f,r)}}function Ri(n,t,e,s,i){const{geometry:r,_indirectBuffer:o}=n;let a=1/0,c=null;for(let d=s,f=s+i;d<f;d++){let u;u=Oe(r,t,e,o?o[d]:d),u&&u.distance<a&&(c=u,a=u.distance)}return c}function Ii(n,t,e,s,i,r,o){const{geometry:a}=e,{index:c}=a,d=a.attributes.position;for(let f=n,u=t+n;f<u;f++){let l;if(l=e.resolveTriangleIndex(f),X(o,l*3,c,d),o.needsUpdate=!0,s(o,l,i,r))return!0}return!1}const us=new D;function Hi(n,t,e,s,i){V.setBuffer(n._roots[t]),Ne(0,n,e,s,i),V.clearBuffer()}function Ne(n,t,e,s,i){const{float32Array:r,uint16Array:o,uint32Array:a}=V,c=n*2;if(K(c,o)){const f=W(n,a),u=j(c,o);Si(t,e,s,f,u,i)}else{const f=J(n);mt(f,r,s,us)&&Ne(f,t,e,s,i);const u=tt(n,a);mt(u,r,s,us)&&Ne(u,t,e,s,i)}}const fs=new D,ki=["x","y","z"];function Vi(n,t,e,s){V.setBuffer(n._roots[t]);const i=Ze(0,n,e,s);return V.clearBuffer(),i}function Ze(n,t,e,s){const{float32Array:i,uint16Array:r,uint32Array:o}=V;let a=n*2;if(K(a,r)){const d=W(n,o),f=j(a,r);return Mi(t,e,s,d,f)}else{const d=zs(n,o),f=ki[d],l=s.direction[f]>=0;let p,y;l?(p=J(n),y=tt(n,o)):(p=tt(n,o),y=J(n));const T=mt(p,i,s,fs)?Ze(p,t,e,s):null;if(T){const E=T.point[f];if(l?E<=i[y+d]:E>=i[y+d+3])return T}const g=mt(y,i,s,fs)?Ze(y,t,e,s):null;return T&&g?T.distance<=g.distance?T:g:T||g||null}}const ce=new et,At=new nt,Ct=new nt,Vt=new lt,ds=new q,le=new q;function Yi(n,t,e,s){V.setBuffer(n._roots[t]);const i=Xe(0,n,e,s);return V.clearBuffer(),i}function Xe(n,t,e,s,i=null){const{float32Array:r,uint16Array:o,uint32Array:a}=V;let c=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),ds.set(e.boundingBox.min,e.boundingBox.max,s),i=ds),K(c,o)){const f=t.geometry,u=f.index,l=f.attributes.position,p=e.index,y=e.attributes.position,O=W(n,a),T=j(c,o);if(Vt.copy(s).invert(),e.boundsTree)return Y(n,r,le),le.matrix.copy(Vt),le.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>le.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(s),g.b.applyMatrix4(s),g.c.applyMatrix4(s),g.needsUpdate=!0;for(let E=O*3,h=(T+O)*3;E<h;E+=3)if(X(Ct,E,u,l),Ct.needsUpdate=!0,g.intersectsTriangle(Ct))return!0;return!1}});for(let m=O*3,g=(T+O)*3;m<g;m+=3){X(At,m,u,l),At.a.applyMatrix4(Vt),At.b.applyMatrix4(Vt),At.c.applyMatrix4(Vt),At.needsUpdate=!0;for(let E=0,h=p.count;E<h;E+=3)if(X(Ct,E,p,y),Ct.needsUpdate=!0,At.intersectsTriangle(Ct))return!0}}else{const f=n+8,u=a[n+6];return Y(f,r,ce),!!(i.intersectsBox(ce)&&Xe(f,t,e,s,i)||(Y(u,r,ce),i.intersectsBox(ce)&&Xe(u,t,e,s,i)))}}const he=new lt,Le=new q,Yt=new q,Ni=new D,Zi=new D,Xi=new D,qi=new D;function $i(n,t,e,s={},i={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Le.set(t.boundingBox.min,t.boundingBox.max,e),Le.needsUpdate=!0;const a=n.geometry,c=a.attributes.position,d=a.index,f=t.attributes.position,u=t.index,l=G.getPrimitive(),p=G.getPrimitive();let y=Ni,O=Zi,T=null,m=null;i&&(T=Xi,m=qi);let g=1/0,E=null,h=null;return he.copy(e).invert(),Yt.matrix.copy(he),n.shapecast({boundsTraverseOrder:_=>Le.distanceToBox(_),intersectsBounds:(_,x,w)=>w<g&&w<o?(x&&(Yt.min.copy(_.min),Yt.max.copy(_.max),Yt.needsUpdate=!0),!0):!1,intersectsRange:(_,x)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:C=>Yt.distanceToBox(C),intersectsBounds:(C,P,b)=>b<g&&b<o,intersectsRange:(C,P)=>{for(let b=C,v=C+P;b<v;b++){X(p,3*b,u,f),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let U=_,L=_+x;U<L;U++){X(l,3*U,d,c),l.needsUpdate=!0;const S=l.distanceToTriangle(p,y,T);if(S<g&&(O.copy(y),m&&m.copy(T),g=S,E=U,h=b),S<r)return!0}}}});{const w=Ft(t);for(let C=0,P=w;C<P;C++){X(p,3*C,u,f),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let b=_,v=_+x;b<v;b++){X(l,3*b,d,c),l.needsUpdate=!0;const U=l.distanceToTriangle(p,y,T);if(U<g&&(O.copy(y),m&&m.copy(T),g=U,E=b,h=C),U<r)return!0}}}}}),G.releasePrimitive(l),G.releasePrimitive(p),g===1/0?null:(s.point?s.point.copy(O):s.point=O.clone(),s.distance=g,s.faceIndex=E,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(he),O.applyMatrix4(he),i.distance=O.sub(i.point).length(),i.faceIndex=h),s)}function Ki(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let r,o,a,c,d=0;const f=n._roots;for(let l=0,p=f.length;l<p;l++)r=f[l],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),u(0,d),d+=r.byteLength;function u(l,p,y=!1){const O=l*2;if(a[O+15]===we){const m=o[l+6],g=a[O+14];let E=1/0,h=1/0,_=1/0,x=-1/0,w=-1/0,C=-1/0;for(let P=m,b=m+g;P<b;P++){const v=3*n.resolveTriangleIndex(P);for(let U=0;U<3;U++){let L=v+U;L=s?s[L]:L;const S=i.getX(L),z=i.getY(L),N=i.getZ(L);S<E&&(E=S),S>x&&(x=S),z<h&&(h=z),z>w&&(w=z),N<_&&(_=N),N>C&&(C=N)}}return c[l+0]!==E||c[l+1]!==h||c[l+2]!==_||c[l+3]!==x||c[l+4]!==w||c[l+5]!==C?(c[l+0]=E,c[l+1]=h,c[l+2]=_,c[l+3]=x,c[l+4]=w,c[l+5]=C,!0):!1}else{const m=l+8,g=o[l+6],E=m+p,h=g+p;let _=y,x=!1,w=!1;t?_||(x=t.has(E),w=t.has(h),_=!x&&!w):(x=!0,w=!0);const C=_||x,P=_||w;let b=!1;C&&(b=u(m,p,_));let v=!1;P&&(v=u(g,p,_));const U=b||v;if(U)for(let L=0;L<3;L++){const S=m+L,z=g+L,N=c[S],zt=c[S+3],Rt=c[z],It=c[z+3];c[l+L]=N<Rt?N:Rt,c[l+L+3]=zt>It?zt:It}return U}}}const ps=new D;function Wi(n,t,e,s,i){V.setBuffer(n._roots[t]),qe(0,n,e,s,i),V.clearBuffer()}function qe(n,t,e,s,i){const{float32Array:r,uint16Array:o,uint32Array:a}=V,c=n*2;if(K(c,o)){const f=W(n,a),u=j(c,o);zi(t,e,s,f,u,i)}else{const f=J(n);mt(f,r,s,ps)&&qe(f,t,e,s,i);const u=tt(n,a);mt(u,r,s,ps)&&qe(u,t,e,s,i)}}const _s=new D,Qi=["x","y","z"];function Gi(n,t,e,s){V.setBuffer(n._roots[t]);const i=$e(0,n,e,s);return V.clearBuffer(),i}function $e(n,t,e,s){const{float32Array:i,uint16Array:r,uint32Array:o}=V;let a=n*2;if(K(a,r)){const d=W(n,o),f=j(a,r);return Ri(t,e,s,d,f)}else{const d=zs(n,o),f=Qi[d],l=s.direction[f]>=0;let p,y;l?(p=J(n),y=tt(n,o)):(p=tt(n,o),y=J(n));const T=mt(p,i,s,_s)?$e(p,t,e,s):null;if(T){const E=T.point[f];if(l?E<=i[y+d]:E>=i[y+d+3])return T}const g=mt(y,i,s,_s)?$e(y,t,e,s):null;return T&&g?T.distance<=g.distance?T:g:T||g||null}}const ue=new et,Pt=new nt,bt=new nt,Nt=new lt,ms=new q,fe=new q;function ji(n,t,e,s){V.setBuffer(n._roots[t]);const i=Ke(0,n,e,s);return V.clearBuffer(),i}function Ke(n,t,e,s,i=null){const{float32Array:r,uint16Array:o,uint32Array:a}=V;let c=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),ms.set(e.boundingBox.min,e.boundingBox.max,s),i=ms),K(c,o)){const f=t.geometry,u=f.index,l=f.attributes.position,p=e.index,y=e.attributes.position,O=W(n,a),T=j(c,o);if(Nt.copy(s).invert(),e.boundsTree)return Y(n,r,fe),fe.matrix.copy(Nt),fe.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>fe.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(s),g.b.applyMatrix4(s),g.c.applyMatrix4(s),g.needsUpdate=!0;for(let E=O,h=T+O;E<h;E++)if(X(bt,3*t.resolveTriangleIndex(E),u,l),bt.needsUpdate=!0,g.intersectsTriangle(bt))return!0;return!1}});for(let m=O,g=T+O;m<g;m++){const E=t.resolveTriangleIndex(m);X(Pt,3*E,u,l),Pt.a.applyMatrix4(Nt),Pt.b.applyMatrix4(Nt),Pt.c.applyMatrix4(Nt),Pt.needsUpdate=!0;for(let h=0,_=p.count;h<_;h+=3)if(X(bt,h,p,y),bt.needsUpdate=!0,Pt.intersectsTriangle(bt))return!0}}else{const f=n+8,u=a[n+6];return Y(f,r,ue),!!(i.intersectsBox(ue)&&Ke(f,t,e,s,i)||(Y(u,r,ue),i.intersectsBox(ue)&&Ke(u,t,e,s,i)))}}const de=new lt,De=new q,Zt=new q,Ji=new D,tn=new D,en=new D,sn=new D;function nn(n,t,e,s={},i={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),De.set(t.boundingBox.min,t.boundingBox.max,e),De.needsUpdate=!0;const a=n.geometry,c=a.attributes.position,d=a.index,f=t.attributes.position,u=t.index,l=G.getPrimitive(),p=G.getPrimitive();let y=Ji,O=tn,T=null,m=null;i&&(T=en,m=sn);let g=1/0,E=null,h=null;return de.copy(e).invert(),Zt.matrix.copy(de),n.shapecast({boundsTraverseOrder:_=>De.distanceToBox(_),intersectsBounds:(_,x,w)=>w<g&&w<o?(x&&(Zt.min.copy(_.min),Zt.max.copy(_.max),Zt.needsUpdate=!0),!0):!1,intersectsRange:(_,x)=>{if(t.boundsTree){const w=t.boundsTree;return w.shapecast({boundsTraverseOrder:C=>Zt.distanceToBox(C),intersectsBounds:(C,P,b)=>b<g&&b<o,intersectsRange:(C,P)=>{for(let b=C,v=C+P;b<v;b++){const U=w.resolveTriangleIndex(b);X(p,3*U,u,f),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let L=_,S=_+x;L<S;L++){const z=n.resolveTriangleIndex(L);X(l,3*z,d,c),l.needsUpdate=!0;const N=l.distanceToTriangle(p,y,T);if(N<g&&(O.copy(y),m&&m.copy(T),g=N,E=L,h=b),N<r)return!0}}}})}else{const w=Ft(t);for(let C=0,P=w;C<P;C++){X(p,3*C,u,f),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let b=_,v=_+x;b<v;b++){const U=n.resolveTriangleIndex(b);X(l,3*U,d,c),l.needsUpdate=!0;const L=l.distanceToTriangle(p,y,T);if(L<g&&(O.copy(y),m&&m.copy(T),g=L,E=b,h=C),L<r)return!0}}}}}),G.releasePrimitive(l),G.releasePrimitive(p),g===1/0?null:(s.point?s.point.copy(O):s.point=O.clone(),s.distance=g,s.faceIndex=E,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(de),O.applyMatrix4(de),i.distance=O.sub(i.point).length(),i.faceIndex=h),s)}function on(){return typeof SharedArrayBuffer<"u"}const Gt=new V.constructor,Ee=new V.constructor,dt=new je(()=>new et),Ut=new et,vt=new et,Se=new et,Me=new et;let Be=!1;function rn(n,t,e,s){if(Be)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Be=!0;const i=n._roots,r=t._roots;let o,a=0,c=0;const d=new lt().copy(e).invert();for(let f=0,u=i.length;f<u;f++){Gt.setBuffer(i[f]),c=0;const l=dt.getPrimitive();Y(0,Gt.float32Array,l),l.applyMatrix4(d);for(let p=0,y=r.length;p<y&&(Ee.setBuffer(r[f]),o=st(0,0,e,d,s,a,c,0,0,l),Ee.clearBuffer(),c+=r[p].length,!o);p++);if(dt.releasePrimitive(l),Gt.clearBuffer(),a+=i[f].length,o)break}return Be=!1,o}function st(n,t,e,s,i,r=0,o=0,a=0,c=0,d=null,f=!1){let u,l;f?(u=Ee,l=Gt):(u=Gt,l=Ee);const p=u.float32Array,y=u.uint32Array,O=u.uint16Array,T=l.float32Array,m=l.uint32Array,g=l.uint16Array,E=n*2,h=t*2,_=K(E,O),x=K(h,g);let w=!1;if(x&&_)f?w=i(W(t,m),j(t*2,g),W(n,y),j(n*2,O),c,o+t,a,r+n):w=i(W(n,y),j(n*2,O),W(t,m),j(t*2,g),a,r+n,c,o+t);else if(x){const C=dt.getPrimitive();Y(t,T,C),C.applyMatrix4(e);const P=J(n),b=tt(n,y);Y(P,p,Ut),Y(b,p,vt);const v=C.intersectsBox(Ut),U=C.intersectsBox(vt);w=v&&st(t,P,s,e,i,o,r,c,a+1,C,!f)||U&&st(t,b,s,e,i,o,r,c,a+1,C,!f),dt.releasePrimitive(C)}else{const C=J(t),P=tt(t,m);Y(C,T,Se),Y(P,T,Me);const b=d.intersectsBox(Se),v=d.intersectsBox(Me);if(b&&v)w=st(n,C,e,s,i,r,o,a,c+1,d,f)||st(n,P,e,s,i,r,o,a,c+1,d,f);else if(b)if(_)w=st(n,C,e,s,i,r,o,a,c+1,d,f);else{const U=dt.getPrimitive();U.copy(Se).applyMatrix4(e);const L=J(n),S=tt(n,y);Y(L,p,Ut),Y(S,p,vt);const z=U.intersectsBox(Ut),N=U.intersectsBox(vt);w=z&&st(C,L,s,e,i,o,r,c,a+1,U,!f)||N&&st(C,S,s,e,i,o,r,c,a+1,U,!f),dt.releasePrimitive(U)}else if(v)if(_)w=st(n,P,e,s,i,r,o,a,c+1,d,f);else{const U=dt.getPrimitive();U.copy(Me).applyMatrix4(e);const L=J(n),S=tt(n,y);Y(L,p,Ut),Y(S,p,vt);const z=U.intersectsBox(Ut),N=U.intersectsBox(vt);w=z&&st(P,L,s,e,i,o,r,c,a+1,U,!f)||N&&st(P,S,s,e,i,o,r,c,a+1,U,!f),dt.releasePrimitive(U)}}return w}const pe=new q,ys=new et;class Je{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,r=t._indirectBuffer,o=s.getIndex();let a;return e.cloneBuffers?a={roots:i.map(c=>c.slice()),index:o.array.slice(),indirectBuffer:r?r.slice():null}:a={roots:i,index:o.array,indirectBuffer:r},a}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:r,indirectBuffer:o}=t,a=new Je(e,{...s,[Pe]:!0});if(a._roots=r,a._indirectBuffer=o||null,s.setIndex){const c=e.getIndex();if(c===null){const d=new vs(t.index,1,!1);e.setIndex(d)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:Ms,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Pe]:!1},e),e.useSharedArrayBuffer&&!on())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Pe]||(wi(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new et)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?Ki:Fi)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(a,c=0){const d=a*2,f=r[d+15]===we;if(f){const u=i[a+6],l=r[d+14];t(c,f,new Float32Array(s,a*4,6),u,l)}else{const u=a+Te/4,l=i[a+6],p=i[a+7];t(c,f,new Float32Array(s,a*4,6),p)||(o(u,c+1),o(l,c+1))}}}raycast(t,e=ts){const s=this._roots,i=this.geometry,r=[],o=e.isMaterial,a=Array.isArray(e),c=i.groups,d=o?e.side:e,f=this.indirect?Wi:Hi;for(let u=0,l=s.length;u<l;u++){const p=a?e[c[u].materialIndex].side:d,y=r.length;if(f(this,u,p,t,r),a){const O=c[u].materialIndex;for(let T=y,m=r.length;T<m;T++)r[T].face.materialIndex=O}}return r}raycastFirst(t,e=ts){const s=this._roots,i=this.geometry,r=e.isMaterial,o=Array.isArray(e);let a=null;const c=i.groups,d=r?e.side:e,f=this.indirect?Gi:Vi;for(let u=0,l=s.length;u<l;u++){const p=o?e[c[u].materialIndex].side:d,y=f(this,u,p,t);y!=null&&(a==null||y.distance<a.distance)&&(a=y,o&&(y.face.materialIndex=c[u].materialIndex))}return a}intersectsGeometry(t,e){let s=!1;const i=this._roots,r=this.indirect?ji:Yi;for(let o=0,a=i.length;o<a&&(s=r(this,o,t,e),!s);o++);return s}shapecast(t){const e=G.getPrimitive(),s=this.indirect?Ii:Bi;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:o,intersectsTriangle:a}=t;if(o&&a){const u=o;o=(l,p,y,O,T)=>u(l,p,y,O,T)?!0:s(l,p,this,a,y,O,e)}else o||(a?o=(u,l,p,y)=>s(u,l,this,a,p,y,e):o=(u,l,p)=>p);let c=!1,d=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const p=f[u];if(c=Ui(this,u,r,o,i,d),c)break;d+=p.byteLength}return G.releasePrimitive(e),c}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const o=G.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,d=this.indirect?y=>{const O=this.resolveTriangleIndex(y);X(o,O*3,a,c)}:y=>{X(o,y*3,a,c)},f=G.getPrimitive(),u=t.geometry.index,l=t.geometry.attributes.position,p=t.indirect?y=>{const O=t.resolveTriangleIndex(y);X(f,O*3,u,l)}:y=>{X(f,y*3,u,l)};if(r){const y=(O,T,m,g,E,h,_,x)=>{for(let w=m,C=m+g;w<C;w++){p(w),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let P=O,b=O+T;P<b;P++)if(d(P),o.needsUpdate=!0,r(o,f,P,w,E,h,_,x))return!0}return!1};if(i){const O=i;i=function(T,m,g,E,h,_,x,w){return O(T,m,g,E,h,_,x,w)?!0:y(T,m,g,E,h,_,x,w)}}else i=y}return rn(this,t,e,i)}intersectsBox(t,e){return pe.set(t.min,t.max,e),pe.needsUpdate=!0,this.shapecast({intersectsBounds:s=>pe.intersectsBox(s),intersectsTriangle:s=>pe.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,o=1/0){return(this.indirect?nn:$i)(this,t,e,s,i,r,o)}closestPointToPoint(t,e={},s=0,i=1/0){return vi(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{Y(0,new Float32Array(s),ys),t.union(ys)}),t}}function gs(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}const Fe=new qs,Ts=new lt,an=Ss.prototype.raycast;function cn(n,t){if(this.geometry.boundsTree){if(this.material===void 0)return;Ts.copy(this.matrixWorld).invert(),Fe.copy(n.ray).applyMatrix4(Ts);const e=this.geometry.boundsTree;if(n.firstHitOnly===!0){const s=gs(e.raycastFirst(Fe,this.material),this,n);s&&t.push(s)}else{const s=e.raycast(Fe,this.material);for(let i=0,r=s.length;i<r;i++){const o=gs(s[i],this,n);o&&t.push(o)}}}else an.call(this,n,t)}function ln(n){return this.boundsTree=new Je(this,n),this.boundsTree}function hn(){this.boundsTree=null}class _t{constructor(){R(this,"trigger",t=>{const e=this.handlers.slice(0);for(const s of e)s(t)});R(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter(e=>e!==t)}reset(){this.handlers.length=0}}class Rs{constructor(t){R(this,"isDisposeable",()=>"dispose"in this&&"onDisposed"in this);R(this,"isResizeable",()=>"resize"in this&&"getSize"in this);R(this,"isUpdateable",()=>"onAfterUpdate"in this&&"onBeforeUpdate"in this&&"update"in this);R(this,"isHideable",()=>"visible"in this);R(this,"isConfigurable",()=>"setup"in this&&"config"in this&&"onSetup"in this);this.components=t}}class un extends Rs{}class Is extends Rs{constructor(e){super(e);R(this,"worlds",new Map);R(this,"onWorldChanged",new _t);R(this,"currentWorld",null);this.onWorldChanged.add(({world:s,action:i})=>{i==="removed"&&this.worlds.delete(s.uuid)})}}class fn extends Is{constructor(){super(...arguments);R(this,"hasCameraControls",()=>"controls"in this)}}const jt=class jt extends un{constructor(e){super(e);R(this,"_disposedComponents",new Set);R(this,"enabled",!0);e.add(jt.uuid,this)}get(){return this._disposedComponents}destroy(e,s=!0,i=!0){e.removeFromParent();const r=e;r.dispose&&r.dispose(),this.disposeGeometryAndMaterials(e,s),i&&r.children&&r.children.length&&this.disposeChildren(r),e.children.length=0}disposeGeometry(e){const s=e;s.boundsTree&&s.disposeBoundsTree(),e.dispose()}disposeGeometryAndMaterials(e,s){const i=e;i.geometry&&this.disposeGeometry(i.geometry),s&&i.material&&jt.disposeMaterial(i),i.material=[],i.geometry=null}disposeChildren(e){for(const s of e.children)this.destroy(s)}static disposeMaterial(e){if(e.material)if(Array.isArray(e.material))for(const s of e.material)s.dispose();else e.material.dispose()}};R(jt,"uuid","76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");let We=jt;class dn extends Is{constructor(e){super(e);R(this,"onDisposed",new _t)}dispose(){const e=this.components.get(We);for(const s of this.three.children){const i=s;i.geometry&&e.destroy(i)}this.three.children=[],this.onDisposed.trigger(),this.onDisposed.reset()}}const Z=class Z{static create(){const t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return`${Z._lut[t&255]+Z._lut[t>>8&255]+Z._lut[t>>16&255]+Z._lut[t>>24&255]}-${Z._lut[e&255]}${Z._lut[e>>8&255]}-${Z._lut[e>>16&15|64]}${Z._lut[e>>24&255]}-${Z._lut[s&63|128]}${Z._lut[s>>8&255]}-${Z._lut[s>>16&255]}${Z._lut[s>>24&255]}${Z._lut[i&255]}${Z._lut[i>>8&255]}${Z._lut[i>>16&255]}${Z._lut[i>>24&255]}`.toLowerCase()}static validate(t){if(!Z._pattern.test(t))throw new Error(`${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`)}};R(Z,"_pattern",/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/),R(Z,"_lut",["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"]);let Qe=Z;const xe=class xe{constructor(){R(this,"onDisposed",new _t);R(this,"list",new Map);R(this,"enabled",!1);R(this,"_clock");R(this,"update",()=>{if(!this.enabled)return;const t=this._clock.getDelta();for(const[e,s]of this.list)s.enabled&&s.isUpdateable()&&s.update(t);requestAnimationFrame(this.update)});this._clock=new $s,xe.setupBVH()}add(t,e){if(this.list.has(t))throw new Error("You're trying to add a component that already exists in the components intance. Use Components.get() instead.");Qe.validate(t),this.list.set(t,e)}get(t){const e=t.uuid;if(!this.list.has(e)){const s=new t(this);return this.list.has(e)||this.add(e,s),s}return this.list.get(e)}init(){this.enabled=!0,this._clock.start(),this.update()}dispose(){this.enabled=!1;for(const[t,e]of this.list)e.enabled=!1,e.isDisposeable()&&e.dispose();this._clock.stop(),this.onDisposed.trigger(),this.onDisposed.reset()}static setupBVH(){es.prototype.computeBoundsTree=ln,es.prototype.disposeBoundsTree=hn,Ss.prototype.raycast=cn}};R(xe,"release","1.4.21");let Es=xe;class En extends dn{constructor(e){super(e);R(this,"isSetup",!1);R(this,"three");R(this,"onSetup",new _t);R(this,"config",{directionalLight:{color:new Ae("white"),intensity:1.5,position:new D(5,10,3)},ambientLight:{color:new Ae("white"),intensity:1}});this.three=new Ks,this.three.background=new Ae(2107698)}setup(e){this.config={...this.config,...e};const s=new Ws(this.config.directionalLight.color,this.config.directionalLight.intensity);s.position.copy(this.config.directionalLight.position);const i=new Qs(this.config.ambientLight.color,this.config.ambientLight.intensity);this.three.add(s,i),this.isSetup=!0,this.onSetup.trigger(this)}}/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const B={LEFT:1,RIGHT:2,MIDDLE:4},A=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),Lt={NONE:0,IN:1,OUT:-1};function yt(n){return n.isPerspectiveCamera}function ft(n){return n.isOrthographicCamera}const Dt=Math.PI*2,xs=Math.PI/2,Hs=1e-5,Xt=Math.PI/180;function it(n,t,e){return Math.max(t,Math.min(e,n))}function k(n,t=Hs){return Math.abs(n)<t}function H(n,t,e=Hs){return k(n-t,e)}function ws(n,t){return Math.round(n/t)*t}function qt(n){return isFinite(n)?n:n<0?-Number.MAX_VALUE:Number.MAX_VALUE}function $t(n){return Math.abs(n)<Number.MAX_VALUE?n:n*(1/0)}function _e(n,t,e,s,i=1/0,r){s=Math.max(1e-4,s);const o=2/s,a=o*r,c=1/(1+a+.48*a*a+.235*a*a*a);let d=n-t;const f=t,u=i*s;d=it(d,-u,u),t=n-d;const l=(e.value+o*d)*r;e.value=(e.value-o*l)*c;let p=t+(d+l)*c;return f-n>0==p>f&&(p=f,e.value=(p-f)/r),p}function Os(n,t,e,s,i=1/0,r,o){s=Math.max(1e-4,s);const a=2/s,c=a*r,d=1/(1+c+.48*c*c+.235*c*c*c);let f=t.x,u=t.y,l=t.z,p=n.x-f,y=n.y-u,O=n.z-l;const T=f,m=u,g=l,E=i*s,h=E*E,_=p*p+y*y+O*O;if(_>h){const z=Math.sqrt(_);p=p/z*E,y=y/z*E,O=O/z*E}f=n.x-p,u=n.y-y,l=n.z-O;const x=(e.x+a*p)*r,w=(e.y+a*y)*r,C=(e.z+a*O)*r;e.x=(e.x-a*x)*d,e.y=(e.y-a*w)*d,e.z=(e.z-a*C)*d,o.x=f+(p+x)*d,o.y=u+(y+w)*d,o.z=l+(O+C)*d;const P=T-n.x,b=m-n.y,v=g-n.z,U=o.x-T,L=o.y-m,S=o.z-g;return P*U+b*L+v*S>0&&(o.x=T,o.y=m,o.z=g,e.x=(o.x-T)/r,e.y=(o.y-m)/r,e.z=(o.z-g)/r),o}function ze(n,t){t.set(0,0),n.forEach(e=>{t.x+=e.clientX,t.y+=e.clientY}),t.x/=n.length,t.y/=n.length}function Re(n,t){return ft(n)?(console.warn(`${t} is not supported in OrthographicCamera`),!0):!1}class pn{constructor(){this._listeners={}}addEventListener(t,e){const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}removeAllEventListeners(t){if(!t){this._listeners={};return}Array.isArray(this._listeners[t])&&(this._listeners[t].length=0)}dispatchEvent(t){const s=this._listeners[t.type];if(s!==void 0){t.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,t)}}}const _n="2.7.3",me=1/8,ks=typeof window<"u",mn=ks&&/Mac/.test(navigator.platform),yn=!(ks&&"PointerEvent"in window);let M,As,ye,Ie,$,F,I,St,Kt,ot,rt,gt,Cs,Ps,Q,Wt,Mt,bs,He,Us,ke,Ve,ge;class Jt extends pn{static install(t){M=t.THREE,As=Object.freeze(new M.Vector3(0,0,0)),ye=Object.freeze(new M.Vector3(0,1,0)),Ie=Object.freeze(new M.Vector3(0,0,1)),$=new M.Vector2,F=new M.Vector3,I=new M.Vector3,St=new M.Vector3,Kt=new M.Vector3,ot=new M.Vector3,rt=new M.Vector3,gt=new M.Vector3,Cs=new M.Vector3,Ps=new M.Vector3,Q=new M.Spherical,Wt=new M.Spherical,Mt=new M.Box3,bs=new M.Box3,He=new M.Sphere,Us=new M.Quaternion,ke=new M.Quaternion,Ve=new M.Matrix4,ge=new M.Raycaster}static get ACTION(){return A}constructor(t,e){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=A.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=Lt.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new M.Vector3,this._focalOffsetVelocity=new M.Vector3,this._zoomVelocity={value:0},this._truckInternal=(h,_,x)=>{let w,C;if(yt(this._camera)){const P=F.copy(this._camera.position).sub(this._target),b=this._camera.getEffectiveFOV()*Xt,v=P.length()*Math.tan(b*.5);w=this.truckSpeed*h*v/this._elementRect.height,C=this.truckSpeed*_*v/this._elementRect.height}else if(ft(this._camera)){const P=this._camera;w=h*(P.right-P.left)/P.zoom/this._elementRect.width,C=_*(P.top-P.bottom)/P.zoom/this._elementRect.height}else return;this.verticalDragToForward?(x?this.setFocalOffset(this._focalOffsetEnd.x+w,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(w,0,!0),this.forward(-C,!0)):x?this.setFocalOffset(this._focalOffsetEnd.x+w,this._focalOffsetEnd.y+C,this._focalOffsetEnd.z,!0):this.truck(w,C,!0)},this._rotateInternal=(h,_)=>{const x=Dt*this.azimuthRotateSpeed*h/this._elementRect.height,w=Dt*this.polarRotateSpeed*_/this._elementRect.height;this.rotate(x,w,!0)},this._dollyInternal=(h,_,x)=>{const w=Math.pow(.95,-h*this.dollySpeed),C=this._sphericalEnd.radius,P=this._sphericalEnd.radius*w,b=it(P,this.minDistance,this.maxDistance),v=b-P;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(P,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(v,!0),this._dollyToNoClamp(b,!0)):this._dollyToNoClamp(b,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?P:b)-C,this._dollyControlCoord.set(_,x)),this._lastDollyDirection=Math.sign(-h)},this._zoomInternal=(h,_,x)=>{const w=Math.pow(.95,h*this.dollySpeed),C=this._zoom,P=this._zoom*w;this.zoomTo(P,!0),this.dollyToCursor&&(this._changedZoom+=P-C,this._dollyControlCoord.set(_,x))},typeof M>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=t,this._yAxisUpSpace=new M.Quaternion().setFromUnitVectors(this._camera.up,ye),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=A.NONE,this._target=new M.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new M.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new M.Spherical().setFromVector3(F.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new M.Vector3,new M.Vector3,new M.Vector3,new M.Vector3],this._updateNearPlaneCorners(),this._boundary=new M.Box3(new M.Vector3(-1/0,-1/0,-1/0),new M.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new M.Vector2,this.mouseButtons={left:A.ROTATE,middle:A.DOLLY,right:A.TRUCK,wheel:yt(this._camera)?A.DOLLY:ft(this._camera)?A.ZOOM:A.NONE},this.touches={one:A.TOUCH_ROTATE,two:yt(this._camera)?A.TOUCH_DOLLY_TRUCK:ft(this._camera)?A.TOUCH_ZOOM_TRUCK:A.NONE,three:A.TOUCH_TRUCK};const s=new M.Vector2,i=new M.Vector2,r=new M.Vector2,o=h=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const w=this._domElement.getBoundingClientRect(),C=h.clientX/w.width,P=h.clientY/w.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||P<this._interactiveArea.top||P>this._interactiveArea.bottom)return}const _=h.pointerType!=="mouse"?null:(h.buttons&B.LEFT)===B.LEFT?B.LEFT:(h.buttons&B.MIDDLE)===B.MIDDLE?B.MIDDLE:(h.buttons&B.RIGHT)===B.RIGHT?B.RIGHT:null;if(_!==null){const w=this._findPointerByMouseButton(_);w&&this._disposePointer(w)}if((h.buttons&B.LEFT)===B.LEFT&&this._lockedPointer)return;const x={pointerId:h.pointerId,clientX:h.clientX,clientY:h.clientY,deltaX:0,deltaY:0,mouseButton:_};this._activePointers.push(x),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),this._isDragging=!0,O(h)},a=h=>{if(!this._enabled||!this._domElement||this._lockedPointer)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const w=this._domElement.getBoundingClientRect(),C=h.clientX/w.width,P=h.clientY/w.height;if(C<this._interactiveArea.left||C>this._interactiveArea.right||P<this._interactiveArea.top||P>this._interactiveArea.bottom)return}const _=(h.buttons&B.LEFT)===B.LEFT?B.LEFT:(h.buttons&B.MIDDLE)===B.MIDDLE?B.MIDDLE:(h.buttons&B.RIGHT)===B.RIGHT?B.RIGHT:null;if(_!==null){const w=this._findPointerByMouseButton(_);w&&this._disposePointer(w)}const x={pointerId:1,clientX:h.clientX,clientY:h.clientY,deltaX:0,deltaY:0,mouseButton:(h.buttons&B.LEFT)===B.LEFT?B.LEFT:(h.buttons&B.MIDDLE)===B.LEFT?B.MIDDLE:(h.buttons&B.RIGHT)===B.LEFT?B.RIGHT:null};this._activePointers.push(x),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.addEventListener("mousemove",d),this._domElement.ownerDocument.addEventListener("mouseup",u),this._isDragging=!0,O(h)},c=h=>{h.cancelable&&h.preventDefault();const _=h.pointerId,x=this._lockedPointer||this._findPointerById(_);if(x){if(x.clientX=h.clientX,x.clientY=h.clientY,x.deltaX=h.movementX,x.deltaY=h.movementY,this._state=0,h.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(h.buttons&B.LEFT)===B.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(h.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(h.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right);T()}},d=h=>{const _=this._lockedPointer||this._findPointerById(1);_&&(_.clientX=h.clientX,_.clientY=h.clientY,_.deltaX=h.movementX,_.deltaY=h.movementY,this._state=0,(this._lockedPointer||(h.buttons&B.LEFT)===B.LEFT)&&(this._state=this._state|this.mouseButtons.left),(h.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(h.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right),T())},f=h=>{const _=this._findPointerById(h.pointerId);if(!(_&&_===this._lockedPointer)){if(_&&this._disposePointer(_),h.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=A.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=A.NONE;m()}},u=()=>{const h=this._findPointerById(1);h&&h===this._lockedPointer||(h&&this._disposePointer(h),this._state=A.NONE,m())};let l=-1;const p=h=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===A.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const P=this._domElement.getBoundingClientRect(),b=h.clientX/P.width,v=h.clientY/P.height;if(b<this._interactiveArea.left||b>this._interactiveArea.right||v<this._interactiveArea.top||v>this._interactiveArea.bottom)return}if(h.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===A.ROTATE||this.mouseButtons.wheel===A.TRUCK){const P=performance.now();l-P<1e3&&this._getClientRect(this._elementRect),l=P}const _=mn?-1:-3,x=h.deltaMode===1?h.deltaY/_:h.deltaY/(_*10),w=this.dollyToCursor?(h.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,C=this.dollyToCursor?(h.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case A.ROTATE:{this._rotateInternal(h.deltaX,h.deltaY),this._isUserControllingRotate=!0;break}case A.TRUCK:{this._truckInternal(h.deltaX,h.deltaY,!1),this._isUserControllingTruck=!0;break}case A.OFFSET:{this._truckInternal(h.deltaX,h.deltaY,!0),this._isUserControllingOffset=!0;break}case A.DOLLY:{this._dollyInternal(-x,w,C),this._isUserControllingDolly=!0;break}case A.ZOOM:{this._zoomInternal(-x,w,C),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},y=h=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===Jt.ACTION.NONE){const _=h instanceof PointerEvent?h.pointerId:(h instanceof MouseEvent,0),x=this._findPointerById(_);x&&this._disposePointer(x),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",u);return}h.preventDefault()}},O=h=>{if(!this._enabled)return;if(ze(this._activePointers,$),this._getClientRect(this._elementRect),s.copy($),i.copy($),this._activePointers.length>=2){const x=$.x-this._activePointers[1].clientX,w=$.y-this._activePointers[1].clientY,C=Math.sqrt(x*x+w*w);r.set(0,C);const P=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,b=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;i.set(P,b)}if(this._state=0,!h)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in h&&h.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(h.buttons&B.LEFT)===B.LEFT&&(this._state=this._state|this.mouseButtons.left),(h.buttons&B.MIDDLE)===B.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(h.buttons&B.RIGHT)===B.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&A.ROTATE)===A.ROTATE||(this._state&A.TOUCH_ROTATE)===A.TOUCH_ROTATE||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&A.TRUCK)===A.TRUCK||(this._state&A.TOUCH_TRUCK)===A.TOUCH_TRUCK||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&A.DOLLY)===A.DOLLY||(this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&A.ZOOM)===A.ZOOM||(this._state&A.TOUCH_ZOOM)===A.TOUCH_ZOOM||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&A.OFFSET)===A.OFFSET||(this._state&A.TOUCH_OFFSET)===A.TOUCH_OFFSET||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},T=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,ze(this._activePointers,$);const _=this._domElement&&document.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,x=_?-_.deltaX:i.x-$.x,w=_?-_.deltaY:i.y-$.y;if(i.copy($),((this._state&A.ROTATE)===A.ROTATE||(this._state&A.TOUCH_ROTATE)===A.TOUCH_ROTATE||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(x,w),this._isUserControllingRotate=!0),(this._state&A.DOLLY)===A.DOLLY||(this._state&A.ZOOM)===A.ZOOM){const C=this.dollyToCursor?(s.x-this._elementRect.x)/this._elementRect.width*2-1:0,P=this.dollyToCursor?(s.y-this._elementRect.y)/this._elementRect.height*-2+1:0,b=this.dollyDragInverted?-1:1;(this._state&A.DOLLY)===A.DOLLY?(this._dollyInternal(b*w*me,C,P),this._isUserControllingDolly=!0):(this._zoomInternal(b*w*me,C,P),this._isUserControllingZoom=!0)}if((this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_ZOOM)===A.TOUCH_ZOOM||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_ZOOM_ROTATE)===A.TOUCH_ZOOM_ROTATE){const C=$.x-this._activePointers[1].clientX,P=$.y-this._activePointers[1].clientY,b=Math.sqrt(C*C+P*P),v=r.y-b;r.set(0,b);const U=this.dollyToCursor?(i.x-this._elementRect.x)/this._elementRect.width*2-1:0,L=this.dollyToCursor?(i.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&A.TOUCH_DOLLY)===A.TOUCH_DOLLY||(this._state&A.TOUCH_DOLLY_ROTATE)===A.TOUCH_DOLLY_ROTATE||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET?(this._dollyInternal(v*me,U,L),this._isUserControllingDolly=!0):(this._zoomInternal(v*me,U,L),this._isUserControllingZoom=!0)}((this._state&A.TRUCK)===A.TRUCK||(this._state&A.TOUCH_TRUCK)===A.TOUCH_TRUCK||(this._state&A.TOUCH_DOLLY_TRUCK)===A.TOUCH_DOLLY_TRUCK||(this._state&A.TOUCH_ZOOM_TRUCK)===A.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(x,w,!1),this._isUserControllingTruck=!0),((this._state&A.OFFSET)===A.OFFSET||(this._state&A.TOUCH_OFFSET)===A.TOUCH_OFFSET||(this._state&A.TOUCH_DOLLY_OFFSET)===A.TOUCH_DOLLY_OFFSET||(this._state&A.TOUCH_ZOOM_OFFSET)===A.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(x,w,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},m=()=>{ze(this._activePointers,$),i.copy($),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",u),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",g),this._domElement.ownerDocument.addEventListener("pointerlockerror",E),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),O())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),document.exitPointerLock(),this.cancel(),this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointerlockchange",g),this._domElement.ownerDocument.removeEventListener("pointerlockerror",E))};const g=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},E=()=>{this.unlockPointer()};this._addAllEventListeners=h=>{this._domElement=h,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",o),yn&&this._domElement.addEventListener("mousedown",a),this._domElement.addEventListener("pointercancel",f),this._domElement.addEventListener("wheel",p,{passive:!1}),this._domElement.addEventListener("contextmenu",y)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",o),this._domElement.removeEventListener("mousedown",a),this._domElement.removeEventListener("pointercancel",f),this._domElement.removeEventListener("wheel",p,{passive:!1}),this._domElement.removeEventListener("contextmenu",y),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",u),this._domElement.ownerDocument.removeEventListener("pointerlockchange",g),this._domElement.ownerDocument.removeEventListener("pointerlockerror",E))},this.cancel=()=>{this._state!==A.NONE&&(this._state=A.NONE,this._activePointers.length=0,m())},e&&this.connect(e),this.update(0)}get camera(){return this._camera}set camera(t){this._camera=t,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._domElement&&(t?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(t){this._spherical.radius===t&&this._sphericalEnd.radius===t||(this._spherical.radius=t,this._sphericalEnd.radius=t,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(t){this._spherical.theta===t&&this._sphericalEnd.theta===t||(this._spherical.theta=t,this._sphericalEnd.theta=t,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(t){this._spherical.phi===t&&this._sphericalEnd.phi===t||(this._spherical.phi=t,this._sphericalEnd.phi=t,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(t){this._boundaryEnclosesCamera=t,this._needsUpdate=!0}set interactiveArea(t){this._interactiveArea.width=it(t.width,0,1),this._interactiveArea.height=it(t.height,0,1),this._interactiveArea.x=it(t.x,0,1-this._interactiveArea.width),this._interactiveArea.y=it(t.y,0,1-this._interactiveArea.height)}addEventListener(t,e){super.addEventListener(t,e)}removeEventListener(t,e){super.removeEventListener(t,e)}rotate(t,e,s=!1){return this.rotateTo(this._sphericalEnd.theta+t,this._sphericalEnd.phi+e,s)}rotateAzimuthTo(t,e=!1){return this.rotateTo(t,this._sphericalEnd.phi,e)}rotatePolarTo(t,e=!1){return this.rotateTo(this._sphericalEnd.theta,t,e)}rotateTo(t,e,s=!1){this._isUserControllingRotate=!1;const i=it(t,this.minAzimuthAngle,this.maxAzimuthAngle),r=it(e,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=i,this._sphericalEnd.phi=r,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,s||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const o=!s||H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(o)}dolly(t,e=!1){return this.dollyTo(this._sphericalEnd.radius-t,e)}dollyTo(t,e=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Lt.NONE,this._changedDolly=0,this._dollyToNoClamp(it(t,this.minDistance,this.maxDistance),e)}_dollyToNoClamp(t,e=!1){const s=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const o=this._collisionTest(),a=H(o,this._spherical.radius);if(!(s>t)&&a)return Promise.resolve();this._sphericalEnd.radius=Math.min(t,o)}else this._sphericalEnd.radius=t;this._needsUpdate=!0,e||(this._spherical.radius=this._sphericalEnd.radius);const r=!e||H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(r)}dollyInFixed(t,e=!1){this._targetEnd.add(this._getCameraDirection(Kt).multiplyScalar(t)),e||this._target.copy(this._targetEnd);const s=!e||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}zoom(t,e=!1){return this.zoomTo(this._zoomEnd+t,e)}zoomTo(t,e=!1){this._isUserControllingZoom=!1,this._zoomEnd=it(t,this.minZoom,this.maxZoom),this._needsUpdate=!0,e||(this._zoom=this._zoomEnd);const s=!e||H(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(s)}pan(t,e,s=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(t,e,s)}truck(t,e,s=!1){this._camera.updateMatrix(),ot.setFromMatrixColumn(this._camera.matrix,0),rt.setFromMatrixColumn(this._camera.matrix,1),ot.multiplyScalar(t),rt.multiplyScalar(-e);const i=F.copy(ot).add(rt),r=I.copy(this._targetEnd).add(i);return this.moveTo(r.x,r.y,r.z,s)}forward(t,e=!1){F.setFromMatrixColumn(this._camera.matrix,0),F.crossVectors(this._camera.up,F),F.multiplyScalar(t);const s=I.copy(this._targetEnd).add(F);return this.moveTo(s.x,s.y,s.z,e)}elevate(t,e=!1){return F.copy(this._camera.up).multiplyScalar(t),this.moveTo(this._targetEnd.x+F.x,this._targetEnd.y+F.y,this._targetEnd.z+F.z,e)}moveTo(t,e,s,i=!1){this._isUserControllingTruck=!1;const r=F.set(t,e,s).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,r,this.boundaryFriction),this._needsUpdate=!0,i||this._target.copy(this._targetEnd);const o=!i||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}lookInDirectionOf(t,e,s,i=!1){const a=F.set(t,e,s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);return this.setPosition(a.x,a.y,a.z,i)}fitToBox(t,e,{cover:s=!1,paddingLeft:i=0,paddingRight:r=0,paddingBottom:o=0,paddingTop:a=0}={}){const c=[],d=t.isBox3?Mt.copy(t):Mt.setFromObject(t);d.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const f=ws(this._sphericalEnd.theta,xs),u=ws(this._sphericalEnd.phi,xs);c.push(this.rotateTo(f,u,e));const l=F.setFromSpherical(this._sphericalEnd).normalize(),p=Us.setFromUnitVectors(l,Ie),y=H(Math.abs(l.y),1);y&&p.multiply(ke.setFromAxisAngle(ye,f)),p.multiply(this._yAxisUpSpaceInverse);const O=bs.makeEmpty();I.copy(d.min).applyQuaternion(p),O.expandByPoint(I),I.copy(d.min).setX(d.max.x).applyQuaternion(p),O.expandByPoint(I),I.copy(d.min).setY(d.max.y).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).setZ(d.min.z).applyQuaternion(p),O.expandByPoint(I),I.copy(d.min).setZ(d.max.z).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).setY(d.min.y).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).setX(d.min.x).applyQuaternion(p),O.expandByPoint(I),I.copy(d.max).applyQuaternion(p),O.expandByPoint(I),O.min.x-=i,O.min.y-=o,O.max.x+=r,O.max.y+=a,p.setFromUnitVectors(Ie,l),y&&p.premultiply(ke.invert()),p.premultiply(this._yAxisUpSpace);const T=O.getSize(F),m=O.getCenter(I).applyQuaternion(p);if(yt(this._camera)){const g=this.getDistanceToFitBox(T.x,T.y,T.z,s);c.push(this.moveTo(m.x,m.y,m.z,e)),c.push(this.dollyTo(g,e)),c.push(this.setFocalOffset(0,0,0,e))}else if(ft(this._camera)){const g=this._camera,E=g.right-g.left,h=g.top-g.bottom,_=s?Math.max(E/T.x,h/T.y):Math.min(E/T.x,h/T.y);c.push(this.moveTo(m.x,m.y,m.z,e)),c.push(this.zoomTo(_,e)),c.push(this.setFocalOffset(0,0,0,e))}return Promise.all(c)}fitToSphere(t,e){const s=[],r=t instanceof M.Sphere?He.copy(t):Jt.createBoundingSphere(t,He);if(s.push(this.moveTo(r.center.x,r.center.y,r.center.z,e)),yt(this._camera)){const o=this.getDistanceToFitSphere(r.radius);s.push(this.dollyTo(o,e))}else if(ft(this._camera)){const o=this._camera.right-this._camera.left,a=this._camera.top-this._camera.bottom,c=2*r.radius,d=Math.min(o/c,a/c);s.push(this.zoomTo(d,e))}return s.push(this.setFocalOffset(0,0,0,e)),Promise.all(s)}setLookAt(t,e,s,i,r,o,a=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Lt.NONE,this._changedDolly=0;const c=I.set(i,r,o),d=F.set(t,e,s);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(d.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,a||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const f=!a||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold)&&H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(f)}lerpLookAt(t,e,s,i,r,o,a,c,d,f,u,l,p,y=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Lt.NONE,this._changedDolly=0;const O=F.set(i,r,o),T=I.set(t,e,s);Q.setFromVector3(T.sub(O).applyQuaternion(this._yAxisUpSpace));const m=St.set(f,u,l),g=I.set(a,c,d);Wt.setFromVector3(g.sub(m).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(O.lerp(m,p));const E=Wt.theta-Q.theta,h=Wt.phi-Q.phi,_=Wt.radius-Q.radius;this._sphericalEnd.set(Q.radius+_*p,Q.phi+h*p,Q.theta+E*p),this.normalizeRotations(),this._needsUpdate=!0,y||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const x=!y||H(this._target.x,this._targetEnd.x,this.restThreshold)&&H(this._target.y,this._targetEnd.y,this.restThreshold)&&H(this._target.z,this._targetEnd.z,this.restThreshold)&&H(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&H(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&H(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(x)}setPosition(t,e,s,i=!1){return this.setLookAt(t,e,s,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,i)}setTarget(t,e,s,i=!1){const r=this.getPosition(F),o=this.setLookAt(r.x,r.y,r.z,t,e,s,i);return this._sphericalEnd.phi=it(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),o}setFocalOffset(t,e,s,i=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(t,e,s),this._needsUpdate=!0,i||this._focalOffset.copy(this._focalOffsetEnd);const r=!i||H(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&H(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&H(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(r)}setOrbitPoint(t,e,s){this._camera.updateMatrixWorld(),ot.setFromMatrixColumn(this._camera.matrixWorldInverse,0),rt.setFromMatrixColumn(this._camera.matrixWorldInverse,1),gt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const i=F.set(t,e,s),r=i.distanceTo(this._camera.position),o=i.sub(this._camera.position);ot.multiplyScalar(o.x),rt.multiplyScalar(o.y),gt.multiplyScalar(o.z),F.copy(ot).add(rt).add(gt),F.z=F.z+r,this.dollyTo(r,!1),this.setFocalOffset(-F.x,F.y,-F.z,!1),this.moveTo(t,e,s,!1)}setBoundary(t){if(!t){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(t),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(t,e,s,i){if(t===null){this._viewport=null;return}this._viewport=this._viewport||new M.Vector4,typeof t=="number"?this._viewport.set(t,e,s,i):this._viewport.copy(t)}getDistanceToFitBox(t,e,s,i=!1){if(Re(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const r=t/e,o=this._camera.getEffectiveFOV()*Xt,a=this._camera.aspect;return((i?r>a:r<a)?e:t/a)*.5/Math.tan(o*.5)+s*.5}getDistanceToFitSphere(t){if(Re(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const e=this._camera.getEffectiveFOV()*Xt,s=Math.atan(Math.tan(e*.5)*this._camera.aspect)*2,i=1<this._camera.aspect?e:s;return t/Math.sin(i*.5)}getTarget(t,e=!0){return(t&&t.isVector3?t:new M.Vector3).copy(e?this._targetEnd:this._target)}getPosition(t,e=!0){return(t&&t.isVector3?t:new M.Vector3).setFromSpherical(e?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e?this._targetEnd:this._target)}getSpherical(t,e=!0){return(t&&t instanceof M.Spherical?t:new M.Spherical).copy(e?this._sphericalEnd:this._spherical)}getFocalOffset(t,e=!0){return(t&&t.isVector3?t:new M.Vector3).copy(e?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%Dt,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=Dt),this._spherical.theta+=Dt*Math.round((this._sphericalEnd.theta-this._spherical.theta)/Dt)}reset(t=!1){if(!H(this._camera.up.x,this._cameraUp0.x)||!H(this._camera.up.y,this._cameraUp0.y)||!H(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const s=this.getPosition(F);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}const e=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,t),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,t),this.zoomTo(this._zoom0,t)];return Promise.all(e)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,ye),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const t=F.subVectors(this._target,this._camera.position).normalize(),e=I.crossVectors(t,this._camera.up);this._camera.up.crossVectors(e,t).normalize(),this._camera.updateMatrixWorld();const s=this.getPosition(F);this.updateCameraUp(),this.setPosition(s.x,s.y,s.z)}update(t){const e=this._sphericalEnd.theta-this._spherical.theta,s=this._sphericalEnd.phi-this._spherical.phi,i=this._sphericalEnd.radius-this._spherical.radius,r=Cs.subVectors(this._targetEnd,this._target),o=Ps.subVectors(this._focalOffsetEnd,this._focalOffset),a=this._zoomEnd-this._zoom;if(k(e))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=_e(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,u,1/0,t),this._needsUpdate=!0}if(k(s))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const u=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=_e(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,u,1/0,t),this._needsUpdate=!0}if(k(i))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const u=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=_e(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,u,this.maxSpeed,t),this._needsUpdate=!0}if(k(r.x)&&k(r.y)&&k(r.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const u=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;Os(this._target,this._targetEnd,this._targetVelocity,u,this.maxSpeed,t,this._target),this._needsUpdate=!0}if(k(o.x)&&k(o.y)&&k(o.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const u=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;Os(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,u,this.maxSpeed,t,this._focalOffset),this._needsUpdate=!0}if(k(a))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const u=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=_e(this._zoom,this._zoomEnd,this._zoomVelocity,u,1/0,t)}if(this.dollyToCursor){if(yt(this._camera)&&this._changedDolly!==0){const u=this._spherical.radius-this._lastDistance,l=this._camera,p=this._getCameraDirection(Kt),y=F.copy(p).cross(l.up).normalize();y.lengthSq()===0&&(y.x=1);const O=I.crossVectors(y,p),T=this._sphericalEnd.radius*Math.tan(l.getEffectiveFOV()*Xt*.5),g=(this._sphericalEnd.radius-u-this._sphericalEnd.radius)/this._sphericalEnd.radius,E=St.copy(this._targetEnd).add(y.multiplyScalar(this._dollyControlCoord.x*T*l.aspect)).add(O.multiplyScalar(this._dollyControlCoord.y*T)),h=F.copy(this._targetEnd).lerp(E,g),_=this._lastDollyDirection===Lt.IN&&this._spherical.radius<=this.minDistance,x=this._lastDollyDirection===Lt.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(_||x)){this._sphericalEnd.radius-=u,this._spherical.radius-=u;const C=I.copy(p).multiplyScalar(-u);h.add(C)}this._boundary.clampPoint(h,h);const w=I.subVectors(h,this._targetEnd);this._targetEnd.copy(h),this._target.add(w),this._changedDolly-=u,k(this._changedDolly)&&(this._changedDolly=0)}else if(ft(this._camera)&&this._changedZoom!==0){const u=this._zoom-this._lastZoom,l=this._camera,p=F.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(l.near+l.far)/(l.near-l.far)).unproject(l),y=I.set(0,0,-1).applyQuaternion(l.quaternion),O=St.copy(p).add(y.multiplyScalar(-p.dot(l.up))),m=-(this._zoom-u-this._zoom)/this._zoom,g=this._getCameraDirection(Kt),E=this._targetEnd.dot(g),h=F.copy(this._targetEnd).lerp(O,m),_=h.dot(g),x=g.multiplyScalar(_-E);h.sub(x),this._boundary.clampPoint(h,h);const w=I.subVectors(h,this._targetEnd);this._targetEnd.copy(h),this._target.add(w),this._changedZoom-=u,k(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const c=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,c),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!k(this._focalOffset.x)||!k(this._focalOffset.y)||!k(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),ot.setFromMatrixColumn(this._camera.matrix,0),rt.setFromMatrixColumn(this._camera.matrix,1),gt.setFromMatrixColumn(this._camera.matrix,2),ot.multiplyScalar(this._focalOffset.x),rt.multiplyScalar(-this._focalOffset.y),gt.multiplyScalar(this._focalOffset.z),F.copy(ot).add(rt).add(gt),this._camera.position.add(F)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),F.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const f=this._needsUpdate;return f&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):f?(this.dispatchEvent({type:"update"}),k(e,this.restThreshold)&&k(s,this.restThreshold)&&k(i,this.restThreshold)&&k(r.x,this.restThreshold)&&k(r.y,this.restThreshold)&&k(r.z,this.restThreshold)&&k(o.x,this.restThreshold)&&k(o.y,this.restThreshold)&&k(o.z,this.restThreshold)&&k(a,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!f&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=f,this._needsUpdate=!1,f}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:qt(this.maxDistance),minZoom:this.minZoom,maxZoom:qt(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:qt(this.maxPolarAngle),minAzimuthAngle:qt(this.minAzimuthAngle),maxAzimuthAngle:qt(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:F.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(t,e=!1){const s=JSON.parse(t);this.enabled=s.enabled,this.minDistance=s.minDistance,this.maxDistance=$t(s.maxDistance),this.minZoom=s.minZoom,this.maxZoom=$t(s.maxZoom),this.minPolarAngle=s.minPolarAngle,this.maxPolarAngle=$t(s.maxPolarAngle),this.minAzimuthAngle=$t(s.minAzimuthAngle),this.maxAzimuthAngle=$t(s.maxAzimuthAngle),this.smoothTime=s.smoothTime,this.draggingSmoothTime=s.draggingSmoothTime,this.dollySpeed=s.dollySpeed,this.truckSpeed=s.truckSpeed,this.dollyToCursor=s.dollyToCursor,this.verticalDragToForward=s.verticalDragToForward,this._target0.fromArray(s.target0),this._position0.fromArray(s.position0),this._zoom0=s.zoom0,this._focalOffset0.fromArray(s.focalOffset0),this.moveTo(s.target[0],s.target[1],s.target[2],e),Q.setFromVector3(F.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(Q.theta,Q.phi,e),this.dollyTo(Q.radius,e),this.zoomTo(s.zoom,e),this.setFocalOffset(s.focalOffset[0],s.focalOffset[1],s.focalOffset[2],e),this._needsUpdate=!0}connect(t){if(this._domElement){console.warn("camera-controls is already connected.");return}t.setAttribute("data-camera-controls-version",_n),this._addAllEventListeners(t),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(t){return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(t){return this._getTargetDirection(t).negate()}_findPointerById(t){return this._activePointers.find(e=>e.pointerId===t)}_findPointerByMouseButton(t){return this._activePointers.find(e=>e.mouseButton===t)}_disposePointer(t){this._activePointers.splice(this._activePointers.indexOf(t),1)}_encloseToBoundary(t,e,s){const i=e.lengthSq();if(i===0)return t;const r=I.copy(e).add(t),a=this._boundary.clampPoint(r,St).sub(r),c=a.lengthSq();if(c===0)return t.add(e);if(c===i)return t;if(s===0)return t.add(e).add(a);{const d=1+s*c/e.dot(a);return t.add(I.copy(e).multiplyScalar(d)).add(a.multiplyScalar(1-s))}}_updateNearPlaneCorners(){if(yt(this._camera)){const t=this._camera,e=t.near,s=t.getEffectiveFOV()*Xt,i=Math.tan(s*.5)*e,r=i*t.aspect;this._nearPlaneCorners[0].set(-r,-i,0),this._nearPlaneCorners[1].set(r,-i,0),this._nearPlaneCorners[2].set(r,i,0),this._nearPlaneCorners[3].set(-r,i,0)}else if(ft(this._camera)){const t=this._camera,e=1/t.zoom,s=t.left*e,i=t.right*e,r=t.top*e,o=t.bottom*e;this._nearPlaneCorners[0].set(s,r,0),this._nearPlaneCorners[1].set(i,r,0),this._nearPlaneCorners[2].set(i,o,0),this._nearPlaneCorners[3].set(s,o,0)}}_collisionTest(){let t=1/0;if(!(this.colliderMeshes.length>=1)||Re(this._camera,"_collisionTest"))return t;const s=this._getTargetDirection(Kt);Ve.lookAt(As,s,this._camera.up);for(let i=0;i<4;i++){const r=I.copy(this._nearPlaneCorners[i]);r.applyMatrix4(Ve);const o=St.addVectors(this._target,r);ge.set(o,s),ge.far=this._spherical.radius+1;const a=ge.intersectObjects(this.colliderMeshes);a.length!==0&&a[0].distance<t&&(t=a[0].distance)}return t}_getClientRect(t){if(!this._domElement)return;const e=this._domElement.getBoundingClientRect();return t.x=e.left,t.y=e.top,this._viewport?(t.x+=this._viewport.x,t.y+=e.height-this._viewport.w-this._viewport.y,t.width=this._viewport.z,t.height=this._viewport.w):(t.width=e.width,t.height=e.height),t}_createOnRestPromise(t){return t?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(e=>{const s=()=>{this.removeEventListener("rest",s),e()};this.addEventListener("rest",s)}))}_addAllEventListeners(t){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(t){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(t){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(t,e=new M.Sphere){const s=e,i=s.center;Mt.makeEmpty(),t.traverseVisible(o=>{o.isMesh&&Mt.expandByObject(o)}),Mt.getCenter(i);let r=0;return t.traverseVisible(o=>{if(!o.isMesh)return;const a=o,c=a.geometry.clone();c.applyMatrix4(a.matrixWorld);const f=c.attributes.position;for(let u=0,l=f.count;u<l;u++)F.fromBufferAttribute(f,u),r=Math.max(r,i.distanceToSquared(F))}),s.radius=Math.sqrt(r),s}}class Vs extends fn{constructor(e){super(e);R(this,"onBeforeUpdate",new _t);R(this,"onAfterUpdate",new _t);R(this,"onAspectUpdated",new _t);R(this,"onDisposed",new _t);R(this,"three");R(this,"_allControls",new Map);R(this,"updateAspect",()=>{var e;if(!(!this.currentWorld||!this.currentWorld.renderer)&&!(this.three instanceof Gs)&&(e=this.currentWorld.renderer)!=null&&e.isResizeable()){const s=this.currentWorld.renderer.getSize();this.three.aspect=s.width/s.height,this.three.updateProjectionMatrix(),this.onAspectUpdated.trigger()}});this.three=this.setupCamera(),this.setupEvents(!0),this.onWorldChanged.add(({action:s,world:i})=>{if(s==="added"){const r=this.newCameraControls();this._allControls.set(i.uuid,r)}if(s==="removed"){const r=this._allControls.get(i.uuid);r&&(r.dispose(),this._allControls.delete(i.uuid))}})}get controls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");const e=this._allControls.get(this.currentWorld.uuid);if(!e)throw new Error("Controls not found!");return e}get enabled(){return this.currentWorld===null?!1:this.controls.enabled}set enabled(e){this.controls.enabled=e}dispose(){this.setupEvents(!1),this.enabled=!1,this.onAspectUpdated.reset(),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.three.removeFromParent(),this.onDisposed.trigger(),this.onDisposed.reset();for(const[e,s]of this._allControls)s.dispose()}update(e){this.enabled&&(this.onBeforeUpdate.trigger(this),this.controls.update(e),this.onAfterUpdate.trigger(this))}setupCamera(){const e=window.innerWidth/window.innerHeight,s=new js(60,e,1,1e3);return s.position.set(50,50,50),s.lookAt(new D(0,0,0)),s}newCameraControls(){if(!this.currentWorld)throw new Error("This camera needs a world to work!");if(!this.currentWorld.renderer)throw new Error("This camera needs a renderer to work!");Jt.install({THREE:Vs.getSubsetOfThree()});const{domElement:e}=this.currentWorld.renderer.three,s=new Jt(this.three,e);return s.smoothTime=.2,s.dollyToCursor=!0,s.infinityDolly=!0,s}setupEvents(e){e?window.addEventListener("resize",this.updateAspect):window.removeEventListener("resize",this.updateAspect)}static getSubsetOfThree(){return{MOUSE:Js,Vector2:Tt,Vector3:D,Vector4:ti,Quaternion:ei,Matrix4:lt,Spherical:si,Box3:et,Sphere:Ds,Raycaster:ii,MathUtils:ni}}}export{Is as B,un as C,We as D,_t as E,En as S,Qe as U,Es as a,Vs as b,Rs as c};
