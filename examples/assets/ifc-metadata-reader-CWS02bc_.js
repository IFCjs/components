var y=Object.defineProperty;var A=(d,t,e)=>t in d?y(d,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[t]=e;var l=(d,t,e)=>(A(d,typeof t!="symbol"?t+"":t,e),e);import{aC as R,f as L,ad as S,H as I,ao as C,ap as G,L as F,aq as D,h as O,ar as T,as as E}from"./index-chvdFvuw.js";class U{constructor(){l(this,"factor",1);l(this,"complement",1)}apply(t){const s=this.getScaleMatrix().multiply(t);t.copy(s)}setUp(t){var o;this.factor=1;const e=this.getLengthUnits(t);if(!e)return;const s=e==null,n=e.Name===void 0||e.Name===null;s||n||(e.Name.value==="FOOT"?this.factor=.3048:((o=e.Prefix)==null?void 0:o.value)==="MILLI"&&(this.complement=.001))}getLengthUnits(t){try{const s=t.GetLineIDsWithType(0,R).get(0),n=t.GetLine(0,s);for(const o of n.Units){if(!o||o.value===null||o.value===void 0)continue;const f=t.GetLine(0,o.value);if(f.UnitType&&f.UnitType.value==="LENGTHUNIT")return f}return null}catch{return console.log("Could not get units"),null}}getScaleMatrix(){const t=this.factor;return new L().fromArray([t,0,0,0,0,t,0,0,0,0,t,0,0,0,0,1])}}class B{constructor(){l(this,"itemsByFloor",{});l(this,"_units",new U)}setUp(t){this._units.setUp(t),this.cleanUp();try{const e=t.GetLineIDsWithType(0,S),s=new Set,n=t.GetLineIDsWithType(0,I);for(let a=0;a<n.size();a++)s.add(n.get(a));const o=t.GetLineIDsWithType(0,C),f=o.size();for(let a=0;a<f;a++){const g=o.get(a),i=t.GetLine(0,g);if(!i||!i.RelatingObject||!i.RelatedObjects)continue;const r=i.RelatingObject.value,h=i.RelatedObjects;for(const c of h){const u=c.value;s.has(u)&&(this.itemsByFloor[u]=r)}}const p={},m=e.size();for(let a=0;a<m;a++){const g=e.get(a),i=t.GetLine(0,g);if(!i||!i.RelatingStructure||!i.RelatedElements)continue;const r=i.RelatingStructure.value,h=i.RelatedElements;if(s.has(r))for(const c of h){p[r]||(p[r]=[]);const u=c.value;p[r].push(u)}else for(const c of h){const u=c.value;this.itemsByFloor[u]=r}}for(const a in p){const g=this.itemsByFloor[a];if(g!==void 0){const i=p[a];for(const r of i)this.itemsByFloor[r]=g}}for(let a=0;a<f;a++){const g=o.get(a),i=t.GetLine(0,g);if(!i||!i.RelatingObject||!i.RelatedObjects)continue;const r=i.RelatingObject.value,h=i.RelatedObjects;for(const c of h){const u=c.value,v=this.itemsByFloor[r];v!==void 0&&(this.itemsByFloor[u]=v)}}}catch{console.log("Could not get floors.")}}cleanUp(){this.itemsByFloor={}}}class z{constructor(){l(this,"includeProperties",!0);l(this,"optionalCategories",[I]);l(this,"coordinate",!0);l(this,"wasm",{path:"",absolute:!1,logLevel:G.LOG_LEVEL_OFF});l(this,"excludedCategories",new Set);l(this,"saveLocations",!1);l(this,"webIfc",{COORDINATE_TO_ORIGIN:!0,OPTIMIZE_PROFILES:!0});l(this,"autoSetWasm",!0);l(this,"customLocateFileHandler",null)}}class j{constructor(){l(this,"defLineMat",new F({color:16777215}))}read(t){const e=t.GetAllAlignments(0),s=t.GetAllCrossSections2D(0),n=t.GetAllCrossSections3D(0),o={IfcAlignment:e,IfcCrossSection2D:s,IfcCrossSection3D:n};return this.get(o)}get(t){if(t.IfcAlignment){const e=new Map;for(const s of t.IfcAlignment){const n=new D;n.absolute=this.getCurves(s.curve3D,n),n.horizontal=this.getCurves(s.horizontal,n),n.vertical=this.getCurves(s.vertical,n),e.set(e.size,n)}return{alignments:e,coordinationMatrix:new L}}}getCurves(t,e){const s=[];let n=0;for(const o of t){const f={};if(o.data)for(const r of o.data){const[h,c]=r.split(": "),u=parseFloat(c);f[h]=u||c}const{points:p}=o,m=new Float32Array(p.length*3);for(let r=0;r<p.length;r++){const{x:h,y:c,z:u}=p[r];m[r*3]=h,m[r*3+1]=c,m[r*3+2]=u||0}const a=new O(m,3),g=new T;g.setAttribute("position",a);const i=new E(n,f,e,g,this.defLineMat);s.push(i.curve),n++}return s}}class x{get(t,e){let s="";const n=t.GetHeaderLine(0,e)||"";if(!n)return s;for(const o of n.arguments)if(o!=null)if(Array.isArray(o))for(const f of o)s+=`${f.value}|`;else s+=`${o.value}|`;return s}}export{j as C,z as I,B as S,x as a};
